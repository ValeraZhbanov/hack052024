
CREATE SCHEMA sch;

CREATE TABLE sch.СтатусыПроектов (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	Название VARCHAR(300),
	МожноРедактировать BOOLEAN NOT NULL DEFAULT (false),
	МожноМенятьВерсию BOOLEAN NOT NULL DEFAULT (false),
	МожноВернутьНаФормирование BOOLEAN NOT NULL DEFAULT (false),
	МожноУтвердить BOOLEAN NOT NULL DEFAULT (false)
);

INSERT INTO sch.СтатусыПроектов (Название, МожноРедактировать, МожноМенятьВерсию, МожноВернутьНаФормирование, МожноУтвердить)
VALUES 
('Формируется', true, true, false, true),
('Утверждено', false, false, true, false);



CREATE TABLE sch.ПроектыРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	ДатаНачала DATE,
	ДатаОкончания DATE,

	КодСтатуса INT NOT NULL REFERENCES sch.СтатусыПроектов (Код),

	CHECK (ДатаНачала <= ДатаОкончания),

	EXCLUDE USING GIST (daterange(ДатаНачала, ДатаОкончания, '[]') with &&)
);

CREATE TABLE sch.ВерсииПроектовРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	ДатаСоздания TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP),
	КодПроектаРасписания INT NOT NULL REFERENCES sch.ПроектыРасписания (Код),
	Утверждено BOOLEAN NOT NULL DEFAULT (false)
);

--
-- Обратная связь, невозможно добавить сразу
--
ALTER TABLE sch.ПроектыРасписания
ADD КодВерсииТекущей INT NULL REFERENCES sch.ВерсииПроектовРасписания (Код);


CREATE TABLE sch.ЗаписиВерсииРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	КодВерсииПроектаРасписания INT NOT NULL REFERENCES sch.ВерсииПроектовРасписания (Код),
	КодДоктора INT NOT NULL REFERENCES hr.Доктора (Код),
	Дата DATE NOT NULL,

	КодТипаРабочейСмены INT NOT NULL REFERENCES hr.ТипыРабочихСмен (Код),

	UNIQUE (КодВерсииПроектаРасписания, КодДоктора, Дата)
);

ALTER TABLE sch.ЗаписиВерсииРасписания
ADD Комментарий VARCHAR(4000) NULL;

CREATE INDEX ДляЗапросов ON sch.ЗаписиВерсииРасписания (
	КодВерсииПроектаРасписания,
	КодДоктора,
	Дата,
	КодТипаРабочейСмены,
	Код
)
INCLUDE (
	Комментарий
);


CREATE TABLE sch.Исследования (
	КодЗаписи INT NOT NULL REFERENCES sch.ЗаписиВерсииРасписания (Код) ON DELETE CASCADE,
	КодТипаИсследования INT NOT NULL REFERENCES med.ТипыИсследований (Код),
	Количество INT NOT NULL,

	CHECK (0 < Количество)
);


CREATE TABLE sch.ЗапросыНаГенерациюРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	КодПроектаРасписания INT NOT NULL REFERENCES sch.ПроектыРасписания (Код),

	КодВерсии INT NULL REFERENCES sch.ВерсииПроектовРасписания (Код),

	Выполняется boolean DEFAULT (false),

	Выполнено boolean DEFAULT (false),

	Активно boolean DEFAULT (true),

	ДатаСоздания TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP)
);


--
-- Преобразует график работы в массив дат
--
CREATE OR REPLACE VIEW sch.НесоответствияВерсий
AS 
SELECT
	ЗаписиДокторов.КодВерсииПроектаРасписания,
	ЗаписиДокторов.КодТипа,
	ЗаписиДокторов.Описание,
	json_agg(json_build_object('Доктор', row_to_json(Доктора), 'Записи', ЗаписиДокторов.Записи) ORDER BY Доктора.Код) Доктора

FROM (
	SELECT
		Записи.КодВерсииПроектаРасписания,
		Записи.КодТипа,
		Записи.Описание,
		Записи.КодДоктора,
		json_agg(json_build_object('КодЗаписи', Записи.Код, 'Дата', Записи.Дата::date, 'ЭтоДень', ЭтоДень, 'ЭтоНеделя', ЭтоНеделя, 'ЭтоМесяц', ЭтоМесяц) ORDER BY Записи.Дата) Записи
	FROM (

		SELECT 
			1 КодТипа,
			ЗаписиВерсииРасписания.Код,
			ЗаписиВерсииРасписания.КодВерсииПроектаРасписания,
			ЗаписиВерсииРасписания.КодДоктора,
			ЗаписиВерсииРасписания.Дата,
			true ЭтоДень,
			false ЭтоНеделя,
			false ЭтоМесяц,
			'Расписание не соответствует желаемому графику работы сотрудника' Описание
		FROM sch.ЗаписиВерсииРасписания
		LEFT JOIN hr.РабочиеСменыДокторов ON РабочиеСменыДокторов.КодДоктора = ЗаписиВерсииРасписания.КодДоктора
										 AND РабочиеСменыДокторов.Дата = ЗаписиВерсииРасписания.Дата
		WHERE РабочиеСменыДокторов.КодДоктора IS NULL
		   OR РабочиеСменыДокторов.КодТипаРабочейСмены <> ЗаписиВерсииРасписания.КодТипаРабочейСмены

		UNION ALL

		SELECT
			2 КодТипа,
			ЗаписиВерсииРасписания1.Код,
			ЗаписиВерсииРасписания1.КодВерсииПроектаРасписания,
			ЗаписиВерсииРасписания1.КодДоктора,
			ЗаписиВерсииРасписания1.Дата,
			true ЭтоДень,
			false ЭтоНеделя,
			false ЭтоМесяц,
			'Смена стоит после ночной смены' Описание
		FROM sch.ЗаписиВерсииРасписания ЗаписиВерсииРасписания0
		INNER JOIN hr.ТипыРабочихСмен ТипыРабочихСмен0 ON ТипыРабочихСмен0.Код = ЗаписиВерсииРасписания0.КодТипаРабочейСмены

		LEFT JOIN sch.ЗаписиВерсииРасписания ЗаписиВерсииРасписания1 ON ЗаписиВерсииРасписания1.КодДоктора = ЗаписиВерсииРасписания0.КодДоктора
															        AND ЗаписиВерсииРасписания1.Дата = (ЗаписиВерсииРасписания0.Дата + '1 day'::interval)
															        AND ЗаписиВерсииРасписания1.КодВерсииПроектаРасписания = ЗаписиВерсииРасписания0.КодВерсииПроектаРасписания

		WHERE ТипыРабочихСмен0.Ночная
		  AND ЗаписиВерсииРасписания1.КодДоктора IS NOT NULL
  
		UNION ALL

		SELECT
			3 КодТипа,
			ЗаписиВерсииРасписания0.Код,
			ЗаписиВерсииРасписания0.КодВерсииПроектаРасписания,
			ЗаписиВерсииРасписания0.КодДоктора,
			ЗаписиВерсииРасписания0.Дата,
			true ЭтоДень,
			false ЭтоНеделя,
			false ЭтоМесяц,
			'Превышен лимит смен дольше 11 часов идущих подряд' Описание
		FROM sch.ЗаписиВерсииРасписания ЗаписиВерсииРасписания0
		INNER JOIN hr.ТипыРабочихСмен ТипыРабочихСмен0 ON ТипыРабочихСмен0.Код = ЗаписиВерсииРасписания0.КодТипаРабочейСмены

		INNER JOIN sch.ЗаписиВерсииРасписания ЗаписиВерсииРасписания1 ON ЗаписиВерсииРасписания1.КодДоктора = ЗаписиВерсииРасписания0.КодДоктора
																     AND ЗаписиВерсииРасписания1.Дата = (ЗаписиВерсииРасписания0.Дата + '-1 day'::interval)
																     AND ЗаписиВерсииРасписания1.КодВерсииПроектаРасписания = ЗаписиВерсииРасписания0.КодВерсииПроектаРасписания
		INNER JOIN hr.ТипыРабочихСмен ТипыРабочихСмен1 ON ТипыРабочихСмен1.Код = ЗаписиВерсииРасписания1.КодТипаРабочейСмены

		INNER JOIN sch.ЗаписиВерсииРасписания ЗаписиВерсииРасписания2 ON ЗаписиВерсииРасписания2.КодДоктора = ЗаписиВерсииРасписания1.КодДоктора
																     AND ЗаписиВерсииРасписания2.Дата = (ЗаписиВерсииРасписания1.Дата + '-1 day'::interval)
																     AND ЗаписиВерсииРасписания2.КодВерсииПроектаРасписания = ЗаписиВерсииРасписания1.КодВерсииПроектаРасписания
		INNER JOIN hr.ТипыРабочихСмен ТипыРабочихСмен2 ON ТипыРабочихСмен2.Код = ЗаписиВерсииРасписания2.КодТипаРабочейСмены

		INNER JOIN sch.ЗаписиВерсииРасписания ЗаписиВерсииРасписанияПрев ON ЗаписиВерсииРасписанияПрев.КодДоктора = ЗаписиВерсииРасписания2.КодДоктора
																        AND ЗаписиВерсииРасписанияПрев.Дата = (ЗаписиВерсииРасписания2.Дата + '-1 day'::interval)
																        AND ЗаписиВерсииРасписанияПрев.КодВерсииПроектаРасписания = ЗаписиВерсииРасписания2.КодВерсииПроектаРасписания
		INNER JOIN hr.ТипыРабочихСмен ТипыРабочихСменПре ON ТипыРабочихСменПре.Код = ЗаписиВерсииРасписанияПрев.КодТипаРабочейСмены

		WHERE ТипыРабочихСмен0.Продолжительность >= '11:00'::interval
		  AND ТипыРабочихСмен1.Продолжительность >= '11:00'::interval
		  AND ТипыРабочихСмен2.Продолжительность >= '11:00'::interval
		  AND (ТипыРабочихСменПре.Продолжительность IS NULL OR ТипыРабочихСменПре.Продолжительность < '11:00'::interval)
  
		UNION ALL

		SELECT
			4 КодТипа,
			NULL Код,
			ЗаписиВерсииРасписания.КодВерсииПроектаРасписания,
			ЗаписиВерсииРасписания.КодДоктора,
			date_trunc('week', Дата) Дата,
			false ЭтоДень,
			true ЭтоНеделя,
			false ЭтоМесяц,
			'Не соблюдено минимальное время отдыха' Описание
		FROM sch.ЗаписиВерсииРасписания
		INNER JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены
		GROUP BY
			КодВерсииПроектаРасписания,
			КодДоктора,
			date_trunc('week', Дата)
		HAVING SUM(ТипыРабочихСмен.Продолжительность) >= 
			('168:00'::interval - (SELECT Значение::varchar::interval FROM stg.Параметры WHERE Параметры.Ключ = 'MinimumRestTimePerWeek'))

		UNION ALL

		SELECT
			5 КодТипа,
			NULL Код,
			ЗаписиВерсииРасписания.КодВерсииПроектаРасписания,
			ЗаписиВерсииРасписания.КодДоктора,
			date_trunc('week', Дата) Дата,
			false ЭтоДень,
			true ЭтоНеделя,
			false ЭтоМесяц,
			'Общее число часов в неделю не соответствует норме' Описание
		FROM hr.Доктора
		INNER JOIN sch.ЗаписиВерсииРасписания ON ЗаписиВерсииРасписания.КодДоктора = Доктора.Код
		INNER JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены
		GROUP BY
			КодВерсииПроектаРасписания,
			КодДоктора,
			date_trunc('week', Дата)
		HAVING NOT SUM(ТипыРабочихСмен.Продолжительность) BETWEEN
				((SELECT Значение::varchar::interval FROM stg.Параметры WHERE Параметры.Ключ = 'ConditionallyMandatoryDistributionFor1RatePerWeek') - (SELECT '30:00:00'::varchar::interval FROM stg.Параметры WHERE Параметры.Ключ = 'TheMaximumErrorOfTheClockIs1RatePerWeek'))
			AND ((SELECT Значение::varchar::interval FROM stg.Параметры WHERE Параметры.Ключ = 'ConditionallyMandatoryDistributionFor1RatePerWeek') + (SELECT Значение::varchar::interval FROM stg.Параметры WHERE Параметры.Ключ = 'TheMaximumErrorOfTheClockIs1RatePerWeek'))

		UNION ALL

		SELECT 
			6 КодТипа,
			NULL Код,
			ЗаписиВерсииРасписания.КодВерсииПроектаРасписания,
			ЗаписиВерсииРасписания.КодДоктора,
			date_trunc('month', Дата) Дата,
			false ЭтоДень,
			false ЭтоНеделя,
			true ЭтоМесяц,
			'Общее число часов в месяц не соответствует норме' Описание
		FROM sch.ЗаписиВерсииРасписания
		INNER JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены
		GROUP BY
			ЗаписиВерсииРасписания.КодВерсииПроектаРасписания,
			ЗаписиВерсииРасписания.КодДоктора,
			date_trunc('month', Дата)
		HAVING SUM(ТипыРабочихСмен.Продолжительность) > (SELECT Значение::varchar::interval FROM stg.Параметры WHERE Параметры.Ключ = 'NumberOfWorkingHoursPerMonth')

		UNION ALL

		SELECT 
			7 КодТипа,
			ЗаписиВерсииРасписания.Код Код,
			ЗаписиВерсииРасписания.КодВерсииПроектаРасписания,
			ЗаписиВерсииРасписания.КодДоктора КодДоктора,
			ЗаписиВерсииРасписания.Дата,
			true ЭтоДень,
			false ЭтоНеделя,
			false ЭтоМесяц,
			'Число одновременно работающих сотрудников превышает лимит' Описание
		FROM (
			SELECT 
				COUNT(*) OVER (PARTITION BY ЗаписиВерсииРасписания.КодВерсииПроектаРасписания, Дата, ТипыРабочихСмен.Код ORDER BY ЗаписиВерсииРасписания.Код) Количество,
				ЗаписиВерсииРасписания.*
			FROM sch.ЗаписиВерсииРасписания
			INNER JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены
		) ЗаписиВерсииРасписания
		WHERE ЗаписиВерсииРасписания.Количество >= (SELECT Значение::varchar::int FROM stg.Параметры WHERE Параметры.Ключ = 'MaximumNumberOfDoctorsPerShift')

	) Записи
	GROUP BY Записи.КодВерсииПроектаРасписания, Записи.КодТипа, Записи.Описание, Записи.КодДоктора
) ЗаписиДокторов
INNER JOIN hr.Доктора ON Доктора.Код = ЗаписиДокторов.КодДоктора
INNER JOIN sch.ВерсииПроектовРасписания ON ВерсииПроектовРасписания.Код = ЗаписиДокторов.КодВерсииПроектаРасписания
                                       AND NOT ВерсииПроектовРасписания.Утверждено
GROUP BY ЗаписиДокторов.КодВерсииПроектаРасписания, ЗаписиДокторов.КодТипа, ЗаписиДокторов.Описание







CREATE OR REPLACE VIEW sch.ЗаписиВерсииРасписанияПодробно
AS
SELECT 
	ЗаписиВерсииРасписания.*,
	ВерсииПроектовРасписания.Утверждено,
	row_to_json(ДоктораПодробно) Доктор, 
	row_to_json(ТипыРабочихСмен) ТипРабочейСмены, 
	Исследования.Исследования
FROM sch.ЗаписиВерсииРасписания
INNER JOIN sch.ВерсииПроектовРасписания ON ВерсииПроектовРасписания.Код = ЗаписиВерсииРасписания.КодВерсииПроектаРасписания
INNER JOIN hr.ДоктораПодробно ON ДоктораПодробно.Код = ЗаписиВерсииРасписания.КодДоктора
INNER JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены
LEFT JOIN (
	SELECT
		Исследования.КодЗаписи,
		json_agg(json_build_object('Тип', row_to_json(ТипыИсследованийПодробно), 'Количество', Исследования.Количество)) Исследования
	FROM sch.Исследования
	INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.Код = Исследования.КодТипаИсследования
	GROUP BY Исследования.КодЗаписи
) Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код;




CREATE OR REPLACE VIEW sch.ПроектыПодробно
AS
SELECT 
	ПроектыРасписания.*,
	row_to_json(СтатусыПроектов) Статус,
	ЗапросыНаГенерациюРасписания.ЗапросыНаГенерациюРасписания,
	ВерсииПроектовРасписания.Версии
FROM sch.ПроектыРасписания
LEFT JOIN sch.СтатусыПроектов ON СтатусыПроектов.Код = ПроектыРасписания.КодСтатуса
LEFT JOIN (
    SELECT КодПроектаРасписания, json_agg(row_to_json(ЗапросыНаГенерациюРасписания)) ЗапросыНаГенерациюРасписания
    FROM sch.ЗапросыНаГенерациюРасписания
	WHERE CURRENT_DATE - INTERVAL'1 day' < ДатаСоздания
    GROUP BY КодПроектаРасписания
) ЗапросыНаГенерациюРасписания ON ЗапросыНаГенерациюРасписания.КодПроектаРасписания = ПроектыРасписания.Код
LEFT JOIN (
    SELECT КодПроектаРасписания, json_agg(row_to_json(ВерсииПроектовРасписания) ORDER BY ВерсииПроектовРасписания.ДатаСоздания DESC, ВерсииПроектовРасписания.Код DESC) Версии
    FROM sch.ВерсииПроектовРасписания
    GROUP BY КодПроектаРасписания
) ВерсииПроектовРасписания ON ВерсииПроектовРасписания.КодПроектаРасписания = ПроектыРасписания.Код;



CREATE OR REPLACE FUNCTION sch.ПоследнийЗапросПроекта (_КодПроекта INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	RETURN QUERY
	SELECT ЗапросыНаГенерациюРасписания.*
	FROM sch.ЗапросыНаГенерациюРасписания
	INNER JOIN (
		SELECT КодПроектаРасписания, MAX(ДатаСоздания) ДатаСоздания
		FROM sch.ЗапросыНаГенерациюРасписания
		GROUP BY КодПроектаРасписания
	) МаксЗапросы ON МаксЗапросы.КодПроектаРасписания = ЗапросыНаГенерациюРасписания.КодПроектаРасписания
				 AND МаксЗапросы.ДатаСоздания = ЗапросыНаГенерациюРасписания.ДатаСоздания
	WHERE ЗапросыНаГенерациюРасписания.КодПроектаРасписания = _КодПроекта;
END
$$;


CREATE OR REPLACE FUNCTION sch.СоздатьЗапросНаГенерацию (_КодПроекта INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN

	PERFORM
	FROM sch.ПроектыРасписания
	CROSS JOIN hr.Доктора
	CROSS JOIN hr.РабочиеСменыСоздатьНаПромежуток (
		Доктора.Код,
		ПроектыРасписания.ДатаНачала,
		ПроектыРасписания.ДатаОкончания,
		(random() * 3 + 1)::int,
		(random() * 14 + 1)::int
	)
	WHERE ПроектыРасписания.Код = _КодПроекта
	  AND NOT EXISTS (
		SELECT *
		FROM hr.РабочиеСменыДокторов
		WHERE РабочиеСменыДокторов.КодДоктора = Доктора.Код
		  AND РабочиеСменыДокторов.Дата BETWEEN ПроектыРасписания.ДатаНачала AND ПроектыРасписания.ДатаОкончания
	  );

	DELETE
	FROM hr.РабочиеСменыДокторов
	WHERE EXISTS (
		SELECT *
		FROM hr.ОшибкиРабочихСменДокторов
		WHERE РабочиеСменыДокторов.КодДоктора = ANY(ОшибкиРабочихСменДокторов.Доктора)
		  AND РабочиеСменыДокторов.Дата = ОшибкиРабочихСменДокторов.Дата
	  )
	  AND EXISTS (
		SELECT *
		FROM sch.ПроектыРасписания
		WHERE ПроектыРасписания.Код = _КодПроекта
			AND РабочиеСменыДокторов.Дата BETWEEN ПроектыРасписания.ДатаНачала AND ПроектыРасписания.ДатаОкончания
	  );

	UPDATE sch.ЗапросыНаГенерациюРасписания 
	SET Активно = false 
	WHERE КодПроектаРасписания = _КодПроекта;

	RETURN QUERY
	INSERT INTO sch.ЗапросыНаГенерациюРасписания (КодПроектаРасписания)
	VALUES (_КодПроекта)
	RETURNING *;
END
$$;

CREATE OR REPLACE FUNCTION sch.ЗапросыНаГенерациюРасписанияPop ()
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	RETURN QUERY
	UPDATE sch.ЗапросыНаГенерациюРасписания
	SET Выполняется = true
	WHERE Код = (
		SELECT Код
		FROM sch.ЗапросыНаГенерациюРасписания
		WHERE Активно 
		  AND NOT Выполняется
		  AND NOT Выполнено
		ORDER BY ДатаСоздания
		LIMIT 1
	)
	RETURNING *;
END
$$;

CREATE OR REPLACE FUNCTION sch.ЗапросыНаГенерациюРасписаниCommit (_Код INT, _Выполнено BOOLEAN, _КодВерсииПроектаРасписания INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	RETURN QUERY
	UPDATE sch.ЗапросыНаГенерациюРасписания 
	SET Выполнено = _Выполнено, 
	    Выполняется = false, 
		КодВерсии = _КодВерсииПроектаРасписания
	WHERE Код = _Код
	RETURNING *;
END
$$;





CREATE OR REPLACE FUNCTION sch.ПроектыРасписанияСоздатьВерсию (
	_КодПроектаРасписания INT,
	_КодВерсииПроектаРасписания INT
)
RETURNS SETOF sch.ВерсииПроектовРасписания
LANGUAGE plpgsql
AS $$
DECLARE _КодВерсииНовой INT;
BEGIN
	SELECT ВерсииПроектовРасписания.Код 
	INTO _КодВерсииНовой
	FROM sch.ВерсииПроектовРасписания
	WHERE ВерсииПроектовРасписания.КодПроектаРасписания = _КодПроектаРасписания
	  AND NOT EXISTS (SELECT * FROM sch.ЗаписиВерсииРасписания WHERE КодВерсииПроектаРасписания = ВерсииПроектовРасписания.Код);

	IF _КодВерсииНовой IS NULL THEN

		INSERT INTO sch.ВерсииПроектовРасписания (КодПроектаРасписания)
		VALUES (_КодПроектаРасписания)
		RETURNING Код INTO _КодВерсииНовой;

		INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
		SELECT _КодВерсииНовой, КодДоктора, Дата, КодТипаРабочейСмены
		FROM sch.ЗаписиВерсииРасписания
		WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания;

		INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
		SELECT Новые.Код, КодТипаИсследования, Количество
		FROM sch.ЗаписиВерсииРасписания
		INNER JOIN sch.ЗаписиВерсииРасписания Новые ON Новые.КодВерсииПроектаРасписания = _КодВерсииНовой
												   AND Новые.КодДоктора = ЗаписиВерсииРасписания.КодДоктора
												   AND Новые.Дата = ЗаписиВерсииРасписания.Дата
		INNER JOIN sch.Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код
		WHERE ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания;

	END IF;

	UPDATE sch.ПроектыРасписания
	SET КодВерсииТекущей = _КодВерсииНовой
	WHERE Код = _КодПроектаРасписания;

	RETURN QUERY
	SELECT *
	FROM sch.ВерсииПроектовРасписания
	WHERE Код = _КодВерсииНовой;
END
$$;



CREATE OR REPLACE FUNCTION sch.ПроектыРасписанияSet (
    _Код INT,
	_ДатаНачала DATE,
	_ДатаОкончания DATE
)
RETURNS SETOF sch.ПроектыПодробно
LANGUAGE plpgsql
AS $$
BEGIN
    IF (_Код IS NULL) THEN
		INSERT INTO sch.ПроектыРасписания (ДатаНачала, ДатаОкончания, КодСтатуса)
        VALUES (_ДатаНачала, _ДатаОкончания, 1)
        RETURNING Код INTO _Код;

		PERFORM sch.ПроектыРасписанияСоздатьВерсию (_Код, NULL);

		UPDATE sch.ПроектыРасписания
		SET КодВерсииТекущей = (SELECT Код FROM sch.ВерсииПроектовРасписания ORDER BY ДатаСоздания DESC LIMIT 1)
		WHERE Код = _Код;
    ELSE
        UPDATE sch.ПроектыРасписания 
        SET ДатаНачала = COALESCE (_ДатаНачала, ДатаНачала),
            ДатаОкончания = COALESCE (_ДатаОкончания, ДатаОкончания)
        WHERE Код = _Код;
	END IF;

	RETURN QUERY
    SELECT *
    FROM sch.ПроектыПодробно
    WHERE Код = _Код;
END
$$;


CREATE OR REPLACE FUNCTION sch.НаФормирование (
	_КодПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE _КодВерсииТекущей INT;
BEGIN

	SELECT КодВерсииТекущей 
	INTO _КодВерсииТекущей
	FROM sch.ПроектыРасписания
	WHERE Код = _КодПроектаРасписания;

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 1
	WHERE Код = _КодПроектаРасписания;

	IF _КодВерсииТекущей IS NOT NULL THEN
		PERFORM sch.ПроектыРасписанияСоздатьВерсию (_КодПроектаРасписания, _КодВерсииТекущей);
	END IF;

	UPDATE sch.ВерсииПроектовРасписания
	SET Утверждено = false
	WHERE КодПроектаРасписания = _КодПроектаРасписания;
END
$$;


CREATE OR REPLACE FUNCTION sch.Утвердить (
	_КодПроектаРасписания INT,
	_КодВерсииПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 2, КодВерсииТекущей = _КодВерсииПроектаРасписания
	WHERE Код = _КодПроектаРасписания;

	UPDATE sch.ВерсииПроектовРасписания
	SET Утверждено = false
	WHERE КодПроектаРасписания = _КодПроектаРасписания;

	UPDATE sch.ВерсииПроектовРасписания
	SET Утверждено = true
	WHERE Код = _КодВерсииПроектаРасписания;

	PERFORM event.СоздатьУведомление (
		'Утверждено новое расписание.', 
		'https://dnd-dusa.ru/telegram/web/schedule', (SELECT array_agg(DISTINCT users.id) 
		FROM sch.ЗаписиВерсииРасписания 
		INNER JOIN public.users ON users.hr_id = ЗаписиВерсииРасписания.КодДоктора
		WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
	));
END
$$;




CREATE OR REPLACE FUNCTION sch.ЗаписиВерсииДобавитьКомментарий (
	_Код INT,
	_Комментарий VARCHAR(4000)
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
	UPDATE sch.ЗаписиВерсииРасписания
	SET Комментарий = _Комментарий
	WHERE Код = _Код;
	
    PERFORM event.СоздатьУведомление(
	    (SELECT Доктора.ФИО || ' написал комментарий к записи расписания ' || to_char(ЗаписиВерсииРасписания.Дата, 'dd.MM.yyyy') || ': ' || ЗаписиВерсииРасписания.Комментарий
		 FROM sch.ЗаписиВерсииРасписания
		 INNER JOIN hr.Доктора ON Доктора.Код = ЗаписиВерсииРасписания.КодДоктора
		 WHERE ЗаписиВерсииРасписания.Код = _Код
		 LIMIT 1),
	    NULL,
	    (SELECT array_agg(id) FROM public.users WHERE role_id = 2)
    );
END
$$;



CREATE OR REPLACE FUNCTION sch.ЗаписиВерсииРасписанияSet (
	_КодВерсииПроектаРасписания INT,
	_КодДоктора INT,
	_Дата DATE,

	_КодТипаРабочейСмены INT,
	_Исследования JSON -- [{"КодТипа": 1, "Количество": 12}, {...}]
)
RETURNS SETOF sch.ЗаписиВерсииРасписанияПодробно
LANGUAGE plpgsql
AS $$
DECLARE _Код INT;
BEGIN
	IF (
		NOT EXISTS (
			SELECT * 
			FROM sch.ВерсииПроектовРасписания
			INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания
			WHERE ВерсииПроектовРасписания.Код = _КодВерсииПроектаРасписания 
			  AND _Дата BETWEEN ПроектыРасписания.ДатаНачала AND ПроектыРасписания.ДатаОкончания
		)
	) THEN
		RAISE EXCEPTION 'Дата не входит в выбранный проект';
	END IF;


	INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
    VALUES (_КодВерсииПроектаРасписания, _КодДоктора, _Дата, _КодТипаРабочейСмены)
    ON CONFLICT (КодВерсииПроектаРасписания, КодДоктора, Дата) DO 
    UPDATE SET КодТипаРабочейСмены = EXCLUDED.КодТипаРабочейСмены
	RETURNING Код INTO _Код;

	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT _Код, КодТипа, Количество
	FROM json_array_elements(_Исследования) q(c),
	     json_to_record(q.c) Исследование (КодТипа INT, Количество INT);

	RETURN QUERY
    SELECT *
    FROM sch.ЗаписиВерсииРасписанияПодробно
    WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
      AND КодДоктора = _КодДоктора
      AND Дата = _Дата;
END
$$;


CREATE OR REPLACE FUNCTION sch.ЗаписиВерсииРасписанияСоздать (
	_КодВерсииПроектаРасписания INT,
	_КодДоктора INT,

	_ДатаНачала DATE,
	_ДатаОкончания DATE,
	_КодГрафикаРаботы INT,

	_КодТипаРабочейСмены INT,
	_Исследования JSON -- [{"КодТипа": 1, "Количество": 12}, {...}]
)
RETURNS SETOF sch.ЗаписиВерсииРасписанияПодробно
LANGUAGE plpgsql
AS $$
BEGIN

	IF (
		NOT EXISTS (
			SELECT * 
			FROM sch.ВерсииПроектовРасписания
			INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания
			WHERE ВерсииПроектовРасписания.Код = _КодВерсииПроектаРасписания 
			  AND _ДатаНачала <= _ДатаОкончания
			  AND ПроектыРасписания.ДатаНачала <= _ДатаНачала 
			  AND _ДатаОкончания <= ПроектыРасписания.ДатаОкончания
		)
	) THEN
		RAISE EXCEPTION 'Дата не входит в выбранный проект';
	END IF;

	DELETE 
    FROM sch.ЗаписиВерсииРасписания
    WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
      AND КодДоктора = _КодДоктора
      AND Дата BETWEEN _ДатаНачала AND _ДатаОкончания;

	CREATE TEMPORARY TABLE _ЗаписиВерсииРасписания (
	   Код INT PRIMARY KEY
	);

	WITH Новые AS (
		INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
		SELECT _КодВерсииПроектаРасписания, _КодДоктора, Дата, _КодТипаРабочейСмены
		FROM hr.ГрафикиРаботыВДатах (_ДатаНачала, _ДатаОкончания, _КодГрафикаРаботы) Дата
		RETURNING Код
	)
	INSERT INTO _ЗаписиВерсииРасписания (Код)
	SELECT Код 
	FROM Новые;

	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT Код, КодТипа, Количество
	FROM json_array_elements(_Исследования) q(c),
	     json_to_record(q.c) Исследование (КодТипа INT, Количество INT)
	CROSS JOIN _ЗаписиВерсииРасписания;

	RETURN QUERY
    SELECT ЗаписиВерсииРасписанияПодробно.*
    FROM sch.ЗаписиВерсииРасписанияПодробно
	INNER JOIN _ЗаписиВерсииРасписания ON _ЗаписиВерсииРасписания.Код = ЗаписиВерсииРасписанияПодробно.Код;

	DROP TABLE _ЗаписиВерсииРасписания;
END
$$;





SELECT (
	SELECT 1
	FROM sch.ЗаписиВерсииРасписанияСозадть(
		2, 
		Доктора.Код, 
		'01.06.2024'::date, 
		'15.06.2024'::date, 
		(random() * 3 + 1)::int, 
		(random() * 9 + 1)::int, 
		('[{"КодТипа": ' || ТипыИсследованийПодробно.Код::varchar || ', "Количество": ' || (random() * 100 + 1)::int::varchar || '}]')::json
	)
    LIMIT 1
)
FROM hr.Доктора
INNER JOIN hr.МодальностиДокторов ON МодальностиДокторов.КодДоктора = Доктора.Код AND МодальностиДокторов.Основная
INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.КодМодальности = МодальностиДокторов.КодМодальности
LIMIT 100




CREATE OR REPLACE VIEW sch.РасписаниеДокторовТаблицей
AS
SELECT
	СменыНаМесяц.КодВерсииПроектаРасписания,
	ВерсииПроектовРасписания.Утверждено,
	Диапазон::date,

	ДоктораПодробно.Код КодДоктора,
	ДоктораПодробно.ФИО,
	ДоктораПодробно.Ставка,
	ДоктораПодробно.ТабНомер,
	ДоктораПодробно.Модальности,

	СменыНаМесяц.ПоДням СменыНаМесяц, 
	СменыНаМесяц.Итог1,
	СменыНаМесяц.Итог2,

	СменыНаМесяц.Итог1 + СменыНаМесяц.Итог2 НормаЧасовПоГрафику,
	НормыДокторовПодробно.НормаЧасов НормаЧасовЗаПолныйМесяц

FROM generate_series(
	date_trunc('month', (SELECT MIN(ДатаНачала) FROM sch.ПроектыРасписания)), 
	date_trunc('month', (SELECT MAX(ДатаОкончания) FROM sch.ПроектыРасписания) + '1 month'::interval) - '1 day'::interval,
	'1 month'::interval
) Диапазон

INNER JOIN (
	SELECT
		date_trunc('month', Диапазон) ДатаНачалаМесяца,
		ВерсииПроектовРасписания.Код КодВерсииПроектаРасписания,
		Доктора.Код КодДоктора,

		json_agg(
			json_build_object(
				'Дата', Диапазон::date, 
				'Запись', row_to_json(ЗаписиВерсииРасписания), 
				'Смена', row_to_json(ТипыРабочихСмен),
				'Исследования', Исследования.Исследования
			) ORDER BY Диапазон
		) ПоДням,

		SUM(CASE WHEN EXTRACT (DAY FROM Диапазон) <= EXTRACT (DAY FROM ((date_trunc('month', Диапазон) + '1 month'::interval) - '1 day'::interval)) / 2 THEN ТипыРабочихСмен.Продолжительность END) Итог1,
		SUM(CASE WHEN EXTRACT (DAY FROM Диапазон) > EXTRACT (DAY FROM ((date_trunc('month', Диапазон) + '1 month'::interval) - '1 day'::interval)) / 2 THEN ТипыРабочихСмен.Продолжительность END) Итог2

	FROM hr.Доктора 

	CROSS JOIN sch.ВерсииПроектовРасписания
	INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания

	CROSS JOIN generate_series(
		date_trunc('month', ПроектыРасписания.ДатаНачала), 
		date_trunc('month', ПроектыРасписания.ДатаОкончания + '1 month'::interval) - '1 day'::interval,
		'1 day'::interval
	) Диапазон
	
	LEFT JOIN sch.ЗаписиВерсииРасписания ON ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = ВерсииПроектовРасписания.Код
	                                    AND ЗаписиВерсииРасписания.КодДоктора = Доктора.Код
	                                    AND ЗаписиВерсииРасписания.Дата = Диапазон
	LEFT JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены

	LEFT JOIN (
		SELECT
			Исследования.КодЗаписи,
			json_agg(json_build_object('Тип', row_to_json(ТипыИсследованийПодробно), 'Количество', Исследования.Количество)) Исследования
		FROM sch.Исследования
		INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.Код = Исследования.КодТипаИсследования
		GROUP BY Исследования.КодЗаписи
	) Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код

	GROUP BY date_trunc('month', Диапазон), 
			 ВерсииПроектовРасписания.Код,
	         Доктора.Код
	
) СменыНаМесяц ON СменыНаМесяц.ДатаНачалаМесяца = Диапазон

INNER JOIN sch.ВерсииПроектовРасписания ON ВерсииПроектовРасписания.Код = СменыНаМесяц.КодВерсииПроектаРасписания
INNER JOIN hr.ДоктораПодробно ON ДоктораПодробно.Код = СменыНаМесяц.КодДоктора
INNER JOIN hr.НормыДокторовПодробно ON НормыДокторовПодробно.КодДоктора = СменыНаМесяц.КодДоктора

ORDER BY Диапазон;




CREATE OR REPLACE VIEW sch.НагрузкаДокторов1
AS
SELECT 
	Доктора.Код КодДоктора,
	ТипыИсследований.Код КодТипаИсследования,
	row_to_json(ТипыИсследований) ТипыИсследований,

	json_agg(json_build_object('Дата', КоличествоИсследований.Дата, 'Значение', COALESCE (КоличествоИсследований.Количество, 0)) ORDER BY КоличествоИсследований.Дата) Исследования,
	SUM(КоличествоИсследований.Количество) Количество

FROM hr.Доктора

INNER JOIN (
	SELECT
		ЗаписиВерсииРасписания.КодДоктора,
		ЗаписиВерсииРасписания.Дата,
		Исследования.КодТипаИсследования,
		SUM(Исследования.Количество) Количество
	FROM sch.ВерсииПроектовРасписания
	INNER JOIN sch.ЗаписиВерсииРасписания ON ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = ВерсииПроектовРасписания.Код
	INNER JOIN sch.Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код
	WHERE ВерсииПроектовРасписания.Утверждено
	  AND ЗаписиВерсииРасписания.Дата BETWEEN (CURRENT_DATE + '-2 month'::interval) AND (CURRENT_DATE + '1 month'::interval)
	GROUP BY
		ЗаписиВерсииРасписания.КодДоктора,
		ЗаписиВерсииРасписания.Дата,
		Исследования.КодТипаИсследования
) КоличествоИсследований ON КоличествоИсследований.КодДоктора = Доктора.Код
INNER JOIN med.ТипыИсследований ON ТипыИсследований.Код = КоличествоИсследований.КодТипаИсследования

GROUP BY Доктора.Код, ТипыИсследований.Код
ORDER BY Доктора.Код, ТипыИсследований.Код;







CREATE OR REPLACE FUNCTION sch.ЗаписиВерсииРасписанияСохранить (
	_КодВерсииПроектаРасписания INT,

	_Данные JSON
)
RETURNS SETOF void
LANGUAGE plpgsql
AS $$
DECLARE _Код INT;
BEGIN


	INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
	SELECT DISTINCT _КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены
	FROM json_array_elements(_Данные) q(c),
	     json_to_record(q.c) Исследование (Дата DATE, КодДоктора INT, КодТипаРабочейСмены INT, КодТипаИсследования INT, Количество INT);


	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT ЗаписиВерсииРасписания.Код, КодТипаИсследования, Количество
	FROM json_array_elements(_Данные) q(c),
	     json_to_record(q.c) Исследование (Дата DATE, КодДоктора INT, КодТипаРабочейСмены INT, КодТипаИсследования INT, Количество INT)
	INNER JOIN sch.ЗаписиВерсииРасписания ON ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
	                                     AND ЗаписиВерсииРасписания.КодДоктора = Исследование.КодДоктора
	                                     AND ЗаписиВерсииРасписания.Дата = Исследование.Дата;
END
$$;


CREATE OR REPLACE VIEW sch.СтатистикаДляПроекта
AS
SELECT
	КодПроекта,
	КодВерсииПроектаРасписания,
	ДатаНачалаНедели,
	ROW_NUMBER() OVER (PARTITION BY КодПроекта ORDER BY ДатаНачалаНедели) НомерНеделиПроекта,
	Значения
FROM (
	SELECT 
		ПроектыРасписания.Код КодПроекта,
		ВерсииПроектовРасписания.Код КодВерсииПроектаРасписания,
		НеделяПроекта::date ДатаНачалаНедели,

		json_agg(json_build_object(
			'ТипИсследований', row_to_json(ТипыИсследований),
			'КоличествоИсследованийПрогнозируемое', COALESCE(СтатистикаОбращений.Значение, 0),

			'КоличествоДокторвРеально', COALESCE(ЗаписиВерсииРасписания.КоличествоДокторов, 0),
			'КоличествоЧасовРеально', COALESCE(EXTRACT (EPOCH FROM ЗаписиВерсииРасписания.КоличествоЧасов) / 60 / 60, 0),
			'КоличествоИсследованийЗаписанно', COALESCE(ЗаписиВерсииРасписания.КоличествоИсследований, 0),

			'КоличествоДокторвДляЗакрытия', (
				COALESCE(СтатистикаОбращений.Значение, 0) / (((ТипыИсследований.МинКолИсследованийЗаСмену + ТипыИсследований.МаксКолИсследованийЗаСмену) / 2 / 8) * 
				(SELECT EXTRACT (EPOCH FROM Значение::varchar::interval) / 60 / 60 FROM stg.Параметры WHERE Ключ = 'ConditionallyMandatoryDistributionFor1RatePerWeek'))
			)::int,

			'МинКоличествоДокторвДляЗакрытия', (
				COALESCE(СтатистикаОбращений.Значение, 0) / ((ТипыИсследований.МаксКолИсследованийЗаСмену / 8) * 
				(SELECT EXTRACT (EPOCH FROM Значение::varchar::interval) / 60 / 60 FROM stg.Параметры WHERE Ключ = 'ConditionallyMandatoryDistributionFor1RatePerWeek'))
			)::int,
			'МаксКоличествоДокторвДляЗакрытия', (
				COALESCE(СтатистикаОбращений.Значение, 0) / ((ТипыИсследований.МинКолИсследованийЗаСмену / 8) * 
				(SELECT EXTRACT (EPOCH FROM Значение::varchar::interval) / 60 / 60 FROM stg.Параметры WHERE Ключ = 'ConditionallyMandatoryDistributionFor1RatePerWeek'))
			)::int,

			'ЧасовДляЗакрытия', (
				COALESCE(СтатистикаОбращений.Значение, 0) / (((ТипыИсследований.МинКолИсследованийЗаСмену + ТипыИсследований.МаксКолИсследованийЗаСмену) / 2 / 8) * 
				(SELECT EXTRACT (EPOCH FROM Значение::varchar::interval) / 60 / 60 FROM stg.Параметры WHERE Ключ = 'TheRateOfHoursFor1Bet'))
			)::int,
			'МинЧасовДляЗакрытия', (
				COALESCE(СтатистикаОбращений.Значение, 0) / ((ТипыИсследований.МаксКолИсследованийЗаСмену / 8) * 
				(SELECT EXTRACT (EPOCH FROM Значение::varchar::interval) / 60 / 60 FROM stg.Параметры WHERE Ключ = 'TheRateOfHoursFor1Bet'))
			)::int,
			'МаксЧасовДляЗакрытия', (
				COALESCE(СтатистикаОбращений.Значение, 0) / ((ТипыИсследований.МинКолИсследованийЗаСмену / 8) * 
				(SELECT EXTRACT (EPOCH FROM Значение::varchar::interval) / 60 / 60 FROM stg.Параметры WHERE Ключ = 'TheRateOfHoursFor1Bet'))
			)::int
		) ORDER BY ТипыИсследований.Код) Значения

	FROM sch.ПроектыРасписания
	LEFT JOIN sch.ВерсииПроектовРасписания ON ВерсииПроектовРасписания.КодПроектаРасписания = ПроектыРасписания.Код

	CROSS JOIN generate_series(
		date_trunc('week', ПроектыРасписания.ДатаНачала),
		date_trunc('week', ПроектыРасписания.ДатаОкончания) + '6 day'::interval,
		'1 week'::interval
	) НеделяПроекта

	CROSS JOIN med.ТипыИсследований

	LEFT JOIN nn.СтатистикаОбращений ON СтатистикаОбращений.Дата = НеделяПроекта
	                                AND СтатистикаОбращений.КодТипаИсследования = ТипыИсследований.Код
	                                AND СтатистикаОбращений.КодТипа = 4

	LEFT JOIN (
		SELECT
			ЗаписиВерсииРасписания.КодВерсииПроектаРасписания,
			date_trunc('week', ЗаписиВерсииРасписания.Дата) Дата,
			Исследования.КодТипаИсследования,
			COUNT(DISTINCT ЗаписиВерсииРасписания.КодДоктора) КоличествоДокторов,
			SUM(ТипыРабочихСмен.Продолжительность) КоличествоЧасов,
			SUM(Исследования.Количество) КоличествоИсследований
		FROM sch.ЗаписиВерсииРасписания
		LEFT JOIN sch.Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код
		LEFT JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены
		GROUP BY ЗаписиВерсииРасписания.КодВерсииПроектаРасписания,
		         date_trunc('week', ЗаписиВерсииРасписания.Дата),
				 Исследования.КодТипаИсследования
	
	) ЗаписиВерсииРасписания ON ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = ВерсииПроектовРасписания.Код
	                        AND ЗаписиВерсииРасписания.КодТипаИсследования = ТипыИсследований.Код
	                        AND ЗаписиВерсииРасписания.Дата = НеделяПроекта


	GROUP BY ПроектыРасписания.Код, ВерсииПроектовРасписания.Код, НеделяПроекта::date
) Запрос



