
CREATE SCHEMA sch;

CREATE TABLE sch.СтатусыПроектов (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	Название VARCHAR(300),
	МожноРедактировать BOOLEAN NOT NULL DEFAULT (false),
	МожноМенятьВерсию BOOLEAN NOT NULL DEFAULT (false),
	МожноВернутьНаФормирование BOOLEAN NOT NULL DEFAULT (false),
	МожноУтвердить BOOLEAN NOT NULL DEFAULT (false)
);

INSERT INTO sch.СтатусыПроектов (Название, МожноРедактировать, МожноМенятьВерсию, МожноВернутьНаФормирование, МожноУтвердить)
VALUES 
('Формируется', true, true, false, true),
('Утверждено', false, false, true, false);



CREATE TABLE sch.ПроектыРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	ДатаНачала DATE,
	ДатаОкончания DATE,

	КодСтатуса INT NOT NULL REFERENCES sch.СтатусыПроектов (Код),

	CHECK (ДатаНачала <= ДатаОкончания),

	EXCLUDE USING GIST (daterange(ДатаНачала, ДатаОкончания, '[]') with &&)
);

CREATE TABLE sch.ВерсииПроектовРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	ДатаСоздания TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP),
	КодПроектаРасписания INT NOT NULL REFERENCES sch.ПроектыРасписания (Код),
	Утверждено BOOLEAN NOT NULL DEFAULT (false)
);


ALTER TABLE sch.ПроектыРасписания
ADD КодВерсииТекущей INT NULL REFERENCES sch.ВерсииПроектовРасписания (Код);


CREATE TABLE sch.ЗаписиВерсииРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	КодВерсииПроектаРасписания INT NOT NULL REFERENCES sch.ВерсииПроектовРасписания (Код),
	КодДоктора INT NOT NULL REFERENCES hr.Доктора (Код),
	Дата DATE NOT NULL,

	КодТипаРабочейСмены INT NOT NULL REFERENCES hr.ТипыРабочихСмен (Код),

	UNIQUE (КодВерсииПроектаРасписания, КодДоктора, Дата)
);


CREATE TABLE sch.Исследования (
	КодЗаписи INT NOT NULL REFERENCES sch.ЗаписиВерсииРасписания (Код) ON DELETE CASCADE,
	КодТипаИсследования INT NOT NULL REFERENCES med.ТипыИсследований (Код),
	Количество INT NOT NULL,

	CHECK (0 < Количество)
);


CREATE TABLE sch.ЗапросыНаГенерациюРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	КодПроектаРасписания INT NOT NULL REFERENCES sch.ПроектыРасписания (Код),

	КодВерсии INT NULL REFERENCES sch.ВерсииПроектовРасписания (Код),

	Выполняется boolean DEFAULT (false),

	Выполнено boolean DEFAULT (false),

	Активно boolean DEFAULT (true),

	ДатаСоздания TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP)
);

CREATE OR REPLACE VIEW sch.НесоответствияВерсий
AS 
SELECT 
	ЗаписиВерсииРасписания.*,
	'Расписание не соответствует графику работы сотрудника' Описание
FROM sch.ЗаписиВерсииРасписания
LEFT JOIN hr.РабочиеСменыДокторов ON РабочиеСменыДокторов.КодДоктора = ЗаписиВерсииРасписания.КодДоктора
                                 AND РабочиеСменыДокторов.Дата = ЗаписиВерсииРасписания.Дата
WHERE РабочиеСменыДокторов.КодДоктора IS NULL
   OR РабочиеСменыДокторов.КодТипаРабочейСмены <> ЗаписиВерсииРасписания.КодТипаРабочейСмены;
   



CREATE OR REPLACE VIEW sch.ЗаписиВерсииРасписанияПодробно
AS
SELECT 
	ЗаписиВерсииРасписания.*,
	row_to_json(ДоктораПодробно) Доктор, 
	row_to_json(ТипыРабочихСмен) ТипРабочейСмены, 
	Исследования.Исследования
FROM sch.ЗаписиВерсииРасписания
INNER JOIN hr.ДоктораПодробно ON ДоктораПодробно.Код = ЗаписиВерсииРасписания.КодДоктора
INNER JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены
LEFT JOIN (
	SELECT
		Исследования.КодЗаписи,
		json_agg(json_build_object('Тип', row_to_json(ТипыИсследованийПодробно), 'Количество', Исследования.Количество)) Исследования
	FROM sch.Исследования
	INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.Код = Исследования.КодТипаИсследования
	GROUP BY Исследования.КодЗаписи
) Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код;




CREATE OR REPLACE VIEW sch.ПроектыПодробно
AS
SELECT 
	ПроектыРасписания.*,
	row_to_json(СтатусыПроектов) Статус,
	ЗапросыНаГенерациюРасписания.ЗапросыНаГенерациюРасписания,
	ВерсииПроектовРасписания.Версии
FROM sch.ПроектыРасписания
LEFT JOIN sch.СтатусыПроектов ON СтатусыПроектов.Код = ПроектыРасписания.КодСтатуса
LEFT JOIN (
    SELECT КодПроектаРасписания, json_agg(row_to_json(ЗапросыНаГенерациюРасписания)) ЗапросыНаГенерациюРасписания
    FROM sch.ЗапросыНаГенерациюРасписания
	WHERE CURRENT_DATE - INTERVAL'1 day' < ДатаСоздания
    GROUP BY КодПроектаРасписания
) ЗапросыНаГенерациюРасписания ON ЗапросыНаГенерациюРасписания.КодПроектаРасписания = ПроектыРасписания.Код
LEFT JOIN (
    SELECT КодПроектаРасписания, json_agg(row_to_json(ВерсииПроектовРасписания) ORDER BY ВерсииПроектовРасписания.ДатаСоздания) Версии
    FROM sch.ВерсииПроектовРасписания
    GROUP BY КодПроектаРасписания
) ВерсииПроектовРасписания ON ВерсииПроектовРасписания.КодПроектаРасписания = ПроектыРасписания.Код;






CREATE OR REPLACE FUNCTION sch.ПоследнийЗапросПроекта (_КодПроекта INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	RETURN QUERY
	SELECT ЗапросыНаГенерациюРасписания.*
	FROM sch.ЗапросыНаГенерациюРасписания
	INNER JOIN (
		SELECT КодПроектаРасписания, MAX(ДатаСоздания) ДатаСоздания
		FROM sch.ЗапросыНаГенерациюРасписания
		GROUP BY КодПроектаРасписания
	) МаксЗапросы ON МаксЗапросы.КодПроектаРасписания = ЗапросыНаГенерациюРасписания.КодПроектаРасписания
				 AND МаксЗапросы.ДатаСоздания = ЗапросыНаГенерациюРасписания.ДатаСоздания
	WHERE ЗапросыНаГенерациюРасписания.КодПроектаРасписания = _КодПроекта;
END
$$;


CREATE OR REPLACE FUNCTION sch.СоздатьЗапросНаГенерацию (_КодПроекта INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	UPDATE sch.ЗапросыНаГенерациюРасписания 
	SET Активно = false 
	WHERE КодПроектаРасписания = _КодПроекта;

	RETURN QUERY
	INSERT INTO sch.ЗапросыНаГенерациюРасписания (КодПроектаРасписания)
	VALUES (_КодПроекта)
	RETURNING *;
END
$$;

CREATE OR REPLACE FUNCTION sch.ЗапросыНаГенерациюРасписанияPop ()
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	RETURN QUERY
	UPDATE sch.ЗапросыНаГенерациюРасписания
	SET Выполняется = true
	WHERE Код = (
		SELECT Код
		FROM sch.ЗапросыНаГенерациюРасписания
		WHERE Активно 
		  AND NOT Выполняется
		  AND NOT Выполнено
		ORDER BY ДатаСоздания
		LIMIT 1
	)
	RETURNING *;
END
$$;

CREATE OR REPLACE FUNCTION sch.ЗапросыНаГенерациюРасписаниCommit (_Код INT, _Выполнено BOOLEAN)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	RETURN QUERY
	UPDATE sch.ЗапросыНаГенерациюРасписания 
	SET Выполнено = _Выполнено, Выполняется = false
	WHERE Код = _Код
	RETURNING *;
END
$$;





CREATE OR REPLACE FUNCTION sch.ПроектыРасписанияСоздатьВерсию (
	_КодПроектаРасписания INT,
	_КодВерсииПроектаРасписания INT
)
RETURNS SETOF sch.ВерсииПроектовРасписания
LANGUAGE plpgsql
AS $$
DECLARE _КодВерсииНовой INT;
BEGIN
	INSERT INTO sch.ВерсииПроектовРасписания (КодПроектаРасписания)
	VALUES (_КодПроектаРасписания)
	RETURNING Код INTO _КодВерсииНовой;

	INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
	SELECT _КодВерсииНовой, КодДоктора, Дата, КодТипаРабочейСмены
	FROM sch.ЗаписиВерсииРасписания
	WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания;

	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT Новые.Код, КодТипаИсследования, Количество
	FROM sch.ЗаписиВерсииРасписания
	INNER JOIN sch.ЗаписиВерсииРасписания Новые ON Новые.КодВерсииПроектаРасписания = _КодВерсииНовой
	                                           AND Новые.КодДоктора = ЗаписиВерсииРасписания.КодДоктора
	                                           AND Новые.Дата = ЗаписиВерсииРасписания.Дата
	INNER JOIN sch.Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код
	WHERE ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания;

	RETURN QUERY
	SELECT *
	FROM sch.ВерсииПроектовРасписания
	WHERE Код = _КодВерсииНовой;
END
$$;



CREATE OR REPLACE FUNCTION sch.ПроектыРасписанияSet (
    _Код INT,
	_ДатаНачала DATE,
	_ДатаОкончания DATE
)
RETURNS SETOF sch.ПроектыПодробно
LANGUAGE plpgsql
AS $$
BEGIN
    IF (_Код IS NULL) THEN
		INSERT INTO sch.ПроектыРасписания (ДатаНачала, ДатаОкончания, КодСтатуса)
        VALUES (_ДатаНачала, _ДатаОкончания, 1)
        RETURNING Код INTO _Код;

		PERFORM sch.ПроектыРасписанияСоздатьВерсию (_Код, NULL);
    ELSE
        UPDATE sch.ПроектыРасписания 
        SET ДатаНачала = COALESCE (_ДатаНачала, ДатаНачала),
            ДатаОкончания = COALESCE (_ДатаОкончания, ДатаОкончания)
        WHERE Код = _Код;
	END IF;

	RETURN QUERY
    SELECT *
    FROM sch.ПроектыПодробно
    WHERE Код = _Код;
END
$$;


CREATE OR REPLACE FUNCTION sch.НаФормирование (
	_КодПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE _КодВерсииТекущей INT;
BEGIN

	SELECT КодВерсииТекущей 
	INTO _КодВерсииТекущей
	FROM sch.ПроектыРасписания
	WHERE Код = _КодПроектаРасписания;

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 1, 
	    КодВерсииТекущей = NULL
	WHERE Код = _КодПроектаРасписания;

	IF _КодВерсииТекущей IS NOT NULL THEN
		PERFORM sch.ПроектыРасписанияСоздатьВерсию (_КодПроектаРасписания, _КодВерсииТекущей);
	END IF;

	UPDATE sch.ВерсииПроектовРасписания
	SET Утверждено = false
	WHERE КодПроектаРасписания = _КодПроектаРасписания;
END
$$;


CREATE OR REPLACE FUNCTION sch.Утвердить (
	_КодПроектаРасписания INT,
	_КодВерсииПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 2, КодВерсииТекущей = _КодВерсииПроектаРасписания
	WHERE Код = _КодПроектаРасписания;

	UPDATE sch.ВерсииПроектовРасписания
	SET Утверждено = true
	WHERE Код = _КодВерсииПроектаРасписания;

	PERFORM event.СоздатьУведомление (
		'Утверждено новое расписание.', 
		NULL, (SELECT array_agg(DISTINCT users.id) 
		FROM sch.Исследования 
		INNER JOIN public.users ON users.hr_id = Исследования.КодДоктора
		WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
	));
END
$$;






CREATE OR REPLACE FUNCTION sch.ЗаписиВерсииРасписанияSet (
	_КодВерсииПроектаРасписания INT,
	_КодДоктора INT,
	_Дата DATE,

	_КодТипаРабочейСмены INT,
	_Исследования JSON -- [{"КодТипа": 1, "Количество": 12}, {...}]
)
RETURNS SETOF sch.ЗаписиВерсииРасписанияПодробно
LANGUAGE plpgsql
AS $$
DECLARE _Код INT;
BEGIN
	IF (
		NOT EXISTS (
			SELECT * 
			FROM sch.ВерсииПроектовРасписания
			INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания
			WHERE ВерсииПроектовРасписания.Код = _КодВерсииПроектаРасписания 
			  AND _Дата BETWEEN ПроектыРасписания.ДатаНачала AND ПроектыРасписания.ДатаОкончания
		)
	) THEN
		RAISE EXCEPTION 'Дата не входит в выбранный проект';
	END IF;


	INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
    VALUES (_КодВерсииПроектаРасписания, _КодДоктора, _Дата, _КодТипаРабочейСмены)
    ON CONFLICT (КодВерсииПроектаРасписания, КодДоктора, Дата) DO 
    UPDATE SET КодТипаРабочейСмены = EXCLUDED.КодТипаРабочейСмены
	RETURNING Код INTO _Код;

	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT _Код, КодТипа, Количество
	FROM json_array_elements(_Исследования) q(c),
	     json_to_record(q.c) Исследование (КодТипа INT, Количество INT);

	RETURN QUERY
    SELECT *
    FROM sch.ЗаписиВерсииРасписанияПодробно
    WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
      AND КодДоктора = _КодДоктора
      AND Дата = _Дата;
END
$$;


CREATE OR REPLACE FUNCTION sch.ЗаписиВерсииРасписанияСоздать (
	_КодВерсииПроектаРасписания INT,
	_КодДоктора INT,

	_ДатаНачала DATE,
	_ДатаОкончания DATE,
	_КодГрафикаРаботы INT,

	_КодТипаРабочейСмены INT,
	_Исследования JSON -- [{"КодТипа": 1, "Количество": 12}, {...}]
)
RETURNS SETOF sch.ЗаписиВерсииРасписанияПодробно
LANGUAGE plpgsql
AS $$
BEGIN

	IF (
		NOT EXISTS (
			SELECT * 
			FROM sch.ВерсииПроектовРасписания
			INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания
			WHERE ВерсииПроектовРасписания.Код = _КодВерсииПроектаРасписания 
			  AND _ДатаНачала <= _ДатаОкончания
			  AND ПроектыРасписания.ДатаНачала <= _ДатаНачала 
			  AND _ДатаОкончания <= ПроектыРасписания.ДатаОкончания
		)
	) THEN
		RAISE EXCEPTION 'Дата не входит в выбранный проект';
	END IF;

	DELETE 
    FROM sch.ЗаписиВерсииРасписания
    WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
      AND КодДоктора = _КодДоктора
      AND Дата BETWEEN _ДатаНачала AND _ДатаОкончания;

	CREATE TEMPORARY TABLE _ЗаписиВерсииРасписания (
	   Код INT PRIMARY KEY
	);

	WITH Новые AS (
		INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
		SELECT _КодВерсииПроектаРасписания, _КодДоктора, Дата, _КодТипаРабочейСмены
		FROM hr.ГрафикиРаботыВДатах (_ДатаНачала, _ДатаОкончания, _КодГрафикаРаботы) Дата
		RETURNING Код
	)
	INSERT INTO _ЗаписиВерсииРасписания (Код)
	SELECT Код 
	FROM Новые;

	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT Код, КодТипа, Количество
	FROM json_array_elements(_Исследования) q(c),
	     json_to_record(q.c) Исследование (КодТипа INT, Количество INT)
	CROSS JOIN _ЗаписиВерсииРасписания;

	RETURN QUERY
    SELECT ЗаписиВерсииРасписанияПодробно.*
    FROM sch.ЗаписиВерсииРасписанияПодробно
	INNER JOIN _ЗаписиВерсииРасписания ON _ЗаписиВерсииРасписания.Код = ЗаписиВерсииРасписанияПодробно.Код;

	DROP TABLE _ЗаписиВерсииРасписания;
END
$$;





SELECT (
	SELECT 1
	FROM sch.ЗаписиВерсииРасписанияСозадть(
		2, 
		Доктора.Код, 
		'01.06.2024'::date, 
		'15.06.2024'::date, 
		(random() * 3 + 1)::int, 
		(random() * 9 + 1)::int, 
		('[{"КодТипа": ' || ТипыИсследованийПодробно.Код::varchar || ', "Количество": ' || (random() * 100 + 1)::int::varchar || '}]')::json
	)
    LIMIT 1
)
FROM hr.Доктора
INNER JOIN hr.МодальностиДокторов ON МодальностиДокторов.КодДоктора = Доктора.Код AND МодальностиДокторов.Основная
INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.КодМодальности = МодальностиДокторов.КодМодальности
LIMIT 100




CREATE OR REPLACE VIEW sch.РасписаниеДокторовТаблицей
AS
SELECT
	СменыНаМесяц.КодВерсииПроектаРасписания,
	ВерсииПроектовРасписания.Утверждено,
	Диапазон::date,

	ДоктораПодробно.Код КодДоктора,
	ДоктораПодробно.ФИО,
	ДоктораПодробно.Ставка,
	ДоктораПодробно.ТабНомер,
	ДоктораПодробно.Модальности,

	СменыНаМесяц.ПоДням СменыНаМесяц, 
	СменыНаМесяц.Итог1,
	СменыНаМесяц.Итог2,

	СменыНаМесяц.Итог1 + СменыНаМесяц.Итог2 НормаЧасовПоГрафику,
	'155:00'::interval НормаЧасовЗаПолныйМесяц

FROM generate_series(
	date_trunc('month', (SELECT MIN(ДатаНачала) FROM sch.ПроектыРасписания)), 
	date_trunc('month', (SELECT MAX(ДатаОкончания) FROM sch.ПроектыРасписания) + '1 month'::interval) - '1 day'::interval,
	'1 month'::interval
) Диапазон

INNER JOIN (
	SELECT
		date_trunc('month', Диапазон) ДатаНачалаМесяца,
		ВерсииПроектовРасписания.Код КодВерсииПроектаРасписания,
		Доктора.Код КодДоктора,

		json_agg(
			json_build_object(
				'Дата', Диапазон::date, 
				'Запись', row_to_json(ЗаписиВерсииРасписания), 
				'Смена', row_to_json(ТипыРабочихСмен)
			) ORDER BY Диапазон
		) ПоДням,

		SUM(CASE WHEN EXTRACT (DAY FROM Диапазон) <= EXTRACT (DAY FROM ((Диапазон + '1 month'::interval) - '1 day'::interval)) / 2 THEN ТипыРабочихСмен.Продолжительность END) Итог1,
		SUM(CASE WHEN EXTRACT (DAY FROM Диапазон) > EXTRACT (DAY FROM ((Диапазон + '1 month'::interval) - '1 day'::interval)) / 2 THEN ТипыРабочихСмен.Продолжительность END) Итог2

	FROM hr.Доктора 

	CROSS JOIN sch.ВерсииПроектовРасписания
	INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания

	CROSS JOIN generate_series(
		date_trunc('month', ПроектыРасписания.ДатаНачала), 
		date_trunc('month', ПроектыРасписания.ДатаОкончания + '1 month'::interval) - '1 day'::interval,
		'1 day'::interval
	) Диапазон
	
	LEFT JOIN sch.ЗаписиВерсииРасписания ON ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = ВерсииПроектовРасписания.Код
	                                    AND ЗаписиВерсииРасписания.КодДоктора = Доктора.Код
	                                    AND ЗаписиВерсииРасписания.Дата = Диапазон
	LEFT JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены

	GROUP BY date_trunc('month', Диапазон), 
			 ВерсииПроектовРасписания.Код,
	         Доктора.Код
	
) СменыНаМесяц ON СменыНаМесяц.ДатаНачалаМесяца = Диапазон

INNER JOIN sch.ВерсииПроектовРасписания ON ВерсииПроектовРасписания.Код = СменыНаМесяц.КодВерсииПроектаРасписания
INNER JOIN hr.ДоктораПодробно ON ДоктораПодробно.Код = СменыНаМесяц.КодДоктора

ORDER BY Диапазон;




CREATE OR REPLACE VIEW sch.НагрузкаДокторов1
AS
SELECT 
	ТекущаяДата.Дата::date, 
	json_agg(json_build_object('Тип', row_to_json(ТипыИсследований), 'Значение', COALESCE (
		СтатистикаОбращений1.Значение,
		0
	)::int)) Значения

FROM (
	SELECT Дата::date Дата
	FROM generate_series(
		(CURRENT_DATE + '30 day'::interval)::date,
		(CURRENT_DATE - '69 day'::interval)::date,
		'-1 day'::interval
	) Дата
) ТекущаяДата

CROSS JOIN med.ТипыИсследований

LEFT JOIN nn.СтатистикаОбращений СтатистикаОбращений1 ON СтатистикаОбращений1.Дата = ТекущаяДата.Дата
													 AND СтатистикаОбращений1.КодТипа = 1
													 AND СтатистикаОбращений1.КодТипаИсследования = ТипыИсследований.Код

LEFT JOIN nn.СтатистикаОбращений СтатистикаОбращений2 ON СтатистикаОбращений2.Дата = ТекущаяДата.Дата
												     AND СтатистикаОбращений2.КодТипа = 2
												     AND СтатистикаОбращений2.КодТипаИсследования = ТипыИсследований.Код

LEFT JOIN nn.СтатистикаОбращений СтатистикаОбращений3 ON ТекущаяДата.Дата BETWEEN СтатистикаОбращений3.Дата AND (СтатистикаОбращений3.Дата + '6 day'::interval)
												     AND СтатистикаОбращений3.КодТипа = 3
												     AND СтатистикаОбращений3.КодТипаИсследования = ТипыИсследований.Код

LEFT JOIN nn.СтатистикаОбращений СтатистикаОбращений4 ON ТекущаяДата.Дата BETWEEN СтатистикаОбращений4.Дата AND (СтатистикаОбращений4.Дата + '6 day'::interval)
												     AND СтатистикаОбращений4.КодТипа = 4
												     AND СтатистикаОбращений4.КодТипаИсследования = ТипыИсследований.Код
GROUP BY ТекущаяДата.Дата
ORDER BY ТекущаяДата.Дата DESC;

