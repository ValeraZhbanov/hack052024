
CREATE SCHEMA sch;

CREATE TABLE sch.СтатусыПроектов (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	Название VARCHAR(300),
	МожноРедактировать BOOLEAN NOT NULL DEFAULT (false),
	МожноМенятьВерсию BOOLEAN NOT NULL DEFAULT (false),
	МожноВернутьНаФормирование BOOLEAN NOT NULL DEFAULT (false),
	МожноУтвердить BOOLEAN NOT NULL DEFAULT (false)
);

INSERT INTO sch.СтатусыПроектов (Название, МожноРедактировать, МожноМенятьВерсию, МожноВернутьНаФормирование, МожноУтвердить)
VALUES 
('Формируется', true, true, false, true),
('Утверждено', false, false, true, false);



CREATE TABLE sch.ПроектыРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	ДатаНачала DATE,
	ДатаОкончания DATE,

	КодСтатуса INT NOT NULL REFERENCES sch.СтатусыПроектов (Код),

	CHECK (ДатаНачала <= ДатаОкончания),

	EXCLUDE USING GIST (daterange(ДатаНачала, ДатаОкончания, '[]') with &&)
);

CREATE TABLE sch.ВерсииПроектовРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	ДатаСоздания TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP),
	КодПроектаРасписания INT NOT NULL REFERENCES sch.ПроектыРасписания (Код),
	Утверждено BOOLEAN NOT NULL DEFAULT (false)
);

--
-- Обратная связь, невозможно добавить сразу
--
ALTER TABLE sch.ПроектыРасписания
ADD КодВерсииТекущей INT NULL REFERENCES sch.ВерсииПроектовРасписания (Код);


CREATE TABLE sch.ЗаписиВерсииРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	КодВерсииПроектаРасписания INT NOT NULL REFERENCES sch.ВерсииПроектовРасписания (Код),
	КодДоктора INT NOT NULL REFERENCES hr.Доктора (Код),
	Дата DATE NOT NULL,

	КодТипаРабочейСмены INT NOT NULL REFERENCES hr.ТипыРабочихСмен (Код),

	UNIQUE (КодВерсииПроектаРасписания, КодДоктора, Дата)
);

CREATE TABLE sch.Исследования (
	КодЗаписи INT NOT NULL REFERENCES sch.ЗаписиВерсииРасписания (Код) ON DELETE CASCADE,
	КодТипаИсследования INT NOT NULL REFERENCES med.ТипыИсследований (Код),
	Количество INT NOT NULL,

	CHECK (0 < Количество)
);


CREATE TABLE sch.ЗапросыНаГенерациюРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	КодПроектаРасписания INT NOT NULL REFERENCES sch.ПроектыРасписания (Код),

	КодВерсии INT NULL REFERENCES sch.ВерсииПроектовРасписания (Код),

	Выполняется boolean DEFAULT (false),

	Выполнено boolean DEFAULT (false),

	Активно boolean DEFAULT (true),

	ДатаСоздания TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP)
);


--
-- Преобразует график работы в массив дат
--
CREATE OR REPLACE VIEW sch.НесоответствияВерсий
AS 
SELECT 
	ЗаписиВерсииРасписания.*,
	'Расписание не соответствует графику работы сотрудника' Описание
FROM sch.ЗаписиВерсииРасписания
LEFT JOIN hr.РабочиеСменыДокторов ON РабочиеСменыДокторов.КодДоктора = ЗаписиВерсииРасписания.КодДоктора
                                 AND РабочиеСменыДокторов.Дата = ЗаписиВерсииРасписания.Дата
WHERE РабочиеСменыДокторов.КодДоктора IS NULL
   OR РабочиеСменыДокторов.КодТипаРабочейСмены <> ЗаписиВерсииРасписания.КодТипаРабочейСмены;
UNION ALL




CREATE OR REPLACE VIEW sch.ЗаписиВерсииРасписанияПодробно
AS
SELECT 
	ЗаписиВерсииРасписания.*,
	ВерсииПроектовРасписания.Утверждено,
	row_to_json(ДоктораПодробно) Доктор, 
	row_to_json(ТипыРабочихСмен) ТипРабочейСмены, 
	Исследования.Исследования
FROM sch.ЗаписиВерсииРасписания
INNER JOIN sch.ВерсииПроектовРасписания ON ВерсииПроектовРасписания.Код = ЗаписиВерсииРасписания.КодВерсииПроектаРасписания
INNER JOIN hr.ДоктораПодробно ON ДоктораПодробно.Код = ЗаписиВерсииРасписания.КодДоктора
INNER JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены
LEFT JOIN (
	SELECT
		Исследования.КодЗаписи,
		json_agg(json_build_object('Тип', row_to_json(ТипыИсследованийПодробно), 'Количество', Исследования.Количество)) Исследования
	FROM sch.Исследования
	INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.Код = Исследования.КодТипаИсследования
	GROUP BY Исследования.КодЗаписи
) Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код;




CREATE OR REPLACE VIEW sch.ПроектыПодробно
AS
SELECT 
	ПроектыРасписания.*,
	row_to_json(СтатусыПроектов) Статус,
	ЗапросыНаГенерациюРасписания.ЗапросыНаГенерациюРасписания,
	ВерсииПроектовРасписания.Версии
FROM sch.ПроектыРасписания
LEFT JOIN sch.СтатусыПроектов ON СтатусыПроектов.Код = ПроектыРасписания.КодСтатуса
LEFT JOIN (
    SELECT КодПроектаРасписания, json_agg(row_to_json(ЗапросыНаГенерациюРасписания)) ЗапросыНаГенерациюРасписания
    FROM sch.ЗапросыНаГенерациюРасписания
	WHERE CURRENT_DATE - INTERVAL'1 day' < ДатаСоздания
    GROUP BY КодПроектаРасписания
) ЗапросыНаГенерациюРасписания ON ЗапросыНаГенерациюРасписания.КодПроектаРасписания = ПроектыРасписания.Код
LEFT JOIN (
    SELECT КодПроектаРасписания, json_agg(row_to_json(ВерсииПроектовРасписания) ORDER BY ВерсииПроектовРасписания.ДатаСоздания) Версии
    FROM sch.ВерсииПроектовРасписания
    GROUP BY КодПроектаРасписания
) ВерсииПроектовРасписания ON ВерсииПроектовРасписания.КодПроектаРасписания = ПроектыРасписания.Код;






CREATE OR REPLACE FUNCTION sch.ПоследнийЗапросПроекта (_КодПроекта INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	RETURN QUERY
	SELECT ЗапросыНаГенерациюРасписания.*
	FROM sch.ЗапросыНаГенерациюРасписания
	INNER JOIN (
		SELECT КодПроектаРасписания, MAX(ДатаСоздания) ДатаСоздания
		FROM sch.ЗапросыНаГенерациюРасписания
		GROUP BY КодПроектаРасписания
	) МаксЗапросы ON МаксЗапросы.КодПроектаРасписания = ЗапросыНаГенерациюРасписания.КодПроектаРасписания
				 AND МаксЗапросы.ДатаСоздания = ЗапросыНаГенерациюРасписания.ДатаСоздания
	WHERE ЗапросыНаГенерациюРасписания.КодПроектаРасписания = _КодПроекта;
END
$$;


CREATE OR REPLACE FUNCTION sch.СоздатьЗапросНаГенерацию (_КодПроекта INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	UPDATE sch.ЗапросыНаГенерациюРасписания 
	SET Активно = false 
	WHERE КодПроектаРасписания = _КодПроекта;

	RETURN QUERY
	INSERT INTO sch.ЗапросыНаГенерациюРасписания (КодПроектаРасписания)
	VALUES (_КодПроекта)
	RETURNING *;
END
$$;

CREATE OR REPLACE FUNCTION sch.ЗапросыНаГенерациюРасписанияPop ()
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	RETURN QUERY
	UPDATE sch.ЗапросыНаГенерациюРасписания
	SET Выполняется = true
	WHERE Код = (
		SELECT Код
		FROM sch.ЗапросыНаГенерациюРасписания
		WHERE Активно 
		  AND NOT Выполняется
		  AND NOT Выполнено
		ORDER BY ДатаСоздания
		LIMIT 1
	)
	RETURNING *;
END
$$;

CREATE OR REPLACE FUNCTION sch.ЗапросыНаГенерациюРасписаниCommit (_Код INT, _Выполнено BOOLEAN, _КодВерсииПроектаРасписания INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
	RETURN QUERY
	UPDATE sch.ЗапросыНаГенерациюРасписания 
	SET Выполнено = _Выполнено, 
	    Выполняется = false, 
		КодВерсии = _КодВерсииПроектаРасписания
	WHERE Код = _Код
	RETURNING *;
END
$$;





CREATE OR REPLACE FUNCTION sch.ПроектыРасписанияСоздатьВерсию (
	_КодПроектаРасписания INT,
	_КодВерсииПроектаРасписания INT
)
RETURNS SETOF sch.ВерсииПроектовРасписания
LANGUAGE plpgsql
AS $$
DECLARE _КодВерсииНовой INT;
BEGIN
	INSERT INTO sch.ВерсииПроектовРасписания (КодПроектаРасписания)
	VALUES (_КодПроектаРасписания)
	RETURNING Код INTO _КодВерсииНовой;

	INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
	SELECT _КодВерсииНовой, КодДоктора, Дата, КодТипаРабочейСмены
	FROM sch.ЗаписиВерсииРасписания
	WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания;

	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT Новые.Код, КодТипаИсследования, Количество
	FROM sch.ЗаписиВерсииРасписания
	INNER JOIN sch.ЗаписиВерсииРасписания Новые ON Новые.КодВерсииПроектаРасписания = _КодВерсииНовой
	                                           AND Новые.КодДоктора = ЗаписиВерсииРасписания.КодДоктора
	                                           AND Новые.Дата = ЗаписиВерсииРасписания.Дата
	INNER JOIN sch.Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код
	WHERE ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания;

	RETURN QUERY
	SELECT *
	FROM sch.ВерсииПроектовРасписания
	WHERE Код = _КодВерсииНовой;
END
$$;



CREATE OR REPLACE FUNCTION sch.ПроектыРасписанияSet (
    _Код INT,
	_ДатаНачала DATE,
	_ДатаОкончания DATE
)
RETURNS SETOF sch.ПроектыПодробно
LANGUAGE plpgsql
AS $$
BEGIN
    IF (_Код IS NULL) THEN
		INSERT INTO sch.ПроектыРасписания (ДатаНачала, ДатаОкончания, КодСтатуса)
        VALUES (_ДатаНачала, _ДатаОкончания, 1)
        RETURNING Код INTO _Код;

		PERFORM sch.ПроектыРасписанияСоздатьВерсию (_Код, NULL);
    ELSE
        UPDATE sch.ПроектыРасписания 
        SET ДатаНачала = COALESCE (_ДатаНачала, ДатаНачала),
            ДатаОкончания = COALESCE (_ДатаОкончания, ДатаОкончания)
        WHERE Код = _Код;
	END IF;

	RETURN QUERY
    SELECT *
    FROM sch.ПроектыПодробно
    WHERE Код = _Код;
END
$$;


CREATE OR REPLACE FUNCTION sch.НаФормирование (
	_КодПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE _КодВерсииТекущей INT;
BEGIN

	SELECT КодВерсииТекущей 
	INTO _КодВерсииТекущей
	FROM sch.ПроектыРасписания
	WHERE Код = _КодПроектаРасписания;

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 1, 
	    КодВерсииТекущей = NULL
	WHERE Код = _КодПроектаРасписания;

	IF _КодВерсииТекущей IS NOT NULL THEN
		PERFORM sch.ПроектыРасписанияСоздатьВерсию (_КодПроектаРасписания, _КодВерсииТекущей);
	END IF;

	UPDATE sch.ВерсииПроектовРасписания
	SET Утверждено = false
	WHERE КодПроектаРасписания = _КодПроектаРасписания;
END
$$;


CREATE OR REPLACE FUNCTION sch.Утвердить (
	_КодПроектаРасписания INT,
	_КодВерсииПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 2, КодВерсииТекущей = _КодВерсииПроектаРасписания
	WHERE Код = _КодПроектаРасписания;

	UPDATE sch.ВерсииПроектовРасписания
	SET Утверждено = false
	WHERE КодПроектаРасписания = _КодПроектаРасписания;

	UPDATE sch.ВерсииПроектовРасписания
	SET Утверждено = true
	WHERE Код = _КодВерсииПроектаРасписания;

	PERFORM event.СоздатьУведомление (
		'Утверждено новое расписание.', 
		'https://dnd-dusa.ru/cabinet', (SELECT array_agg(DISTINCT users.id) 
		FROM sch.ЗаписиВерсииРасписания 
		INNER JOIN public.users ON users.hr_id = ЗаписиВерсииРасписания.КодДоктора
		WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
	));
END
$$;






CREATE OR REPLACE FUNCTION sch.ЗаписиВерсииРасписанияSet (
	_КодВерсииПроектаРасписания INT,
	_КодДоктора INT,
	_Дата DATE,

	_КодТипаРабочейСмены INT,
	_Исследования JSON -- [{"КодТипа": 1, "Количество": 12}, {...}]
)
RETURNS SETOF sch.ЗаписиВерсииРасписанияПодробно
LANGUAGE plpgsql
AS $$
DECLARE _Код INT;
BEGIN
	IF (
		NOT EXISTS (
			SELECT * 
			FROM sch.ВерсииПроектовРасписания
			INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания
			WHERE ВерсииПроектовРасписания.Код = _КодВерсииПроектаРасписания 
			  AND _Дата BETWEEN ПроектыРасписания.ДатаНачала AND ПроектыРасписания.ДатаОкончания
		)
	) THEN
		RAISE EXCEPTION 'Дата не входит в выбранный проект';
	END IF;


	INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
    VALUES (_КодВерсииПроектаРасписания, _КодДоктора, _Дата, _КодТипаРабочейСмены)
    ON CONFLICT (КодВерсииПроектаРасписания, КодДоктора, Дата) DO 
    UPDATE SET КодТипаРабочейСмены = EXCLUDED.КодТипаРабочейСмены
	RETURNING Код INTO _Код;

	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT _Код, КодТипа, Количество
	FROM json_array_elements(_Исследования) q(c),
	     json_to_record(q.c) Исследование (КодТипа INT, Количество INT);

	RETURN QUERY
    SELECT *
    FROM sch.ЗаписиВерсииРасписанияПодробно
    WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
      AND КодДоктора = _КодДоктора
      AND Дата = _Дата;
END
$$;


CREATE OR REPLACE FUNCTION sch.ЗаписиВерсииРасписанияСоздать (
	_КодВерсииПроектаРасписания INT,
	_КодДоктора INT,

	_ДатаНачала DATE,
	_ДатаОкончания DATE,
	_КодГрафикаРаботы INT,

	_КодТипаРабочейСмены INT,
	_Исследования JSON -- [{"КодТипа": 1, "Количество": 12}, {...}]
)
RETURNS SETOF sch.ЗаписиВерсииРасписанияПодробно
LANGUAGE plpgsql
AS $$
BEGIN

	IF (
		NOT EXISTS (
			SELECT * 
			FROM sch.ВерсииПроектовРасписания
			INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания
			WHERE ВерсииПроектовРасписания.Код = _КодВерсииПроектаРасписания 
			  AND _ДатаНачала <= _ДатаОкончания
			  AND ПроектыРасписания.ДатаНачала <= _ДатаНачала 
			  AND _ДатаОкончания <= ПроектыРасписания.ДатаОкончания
		)
	) THEN
		RAISE EXCEPTION 'Дата не входит в выбранный проект';
	END IF;

	DELETE 
    FROM sch.ЗаписиВерсииРасписания
    WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
      AND КодДоктора = _КодДоктора
      AND Дата BETWEEN _ДатаНачала AND _ДатаОкончания;

	CREATE TEMPORARY TABLE _ЗаписиВерсииРасписания (
	   Код INT PRIMARY KEY
	);

	WITH Новые AS (
		INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
		SELECT _КодВерсииПроектаРасписания, _КодДоктора, Дата, _КодТипаРабочейСмены
		FROM hr.ГрафикиРаботыВДатах (_ДатаНачала, _ДатаОкончания, _КодГрафикаРаботы) Дата
		RETURNING Код
	)
	INSERT INTO _ЗаписиВерсииРасписания (Код)
	SELECT Код 
	FROM Новые;

	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT Код, КодТипа, Количество
	FROM json_array_elements(_Исследования) q(c),
	     json_to_record(q.c) Исследование (КодТипа INT, Количество INT)
	CROSS JOIN _ЗаписиВерсииРасписания;

	RETURN QUERY
    SELECT ЗаписиВерсииРасписанияПодробно.*
    FROM sch.ЗаписиВерсииРасписанияПодробно
	INNER JOIN _ЗаписиВерсииРасписания ON _ЗаписиВерсииРасписания.Код = ЗаписиВерсииРасписанияПодробно.Код;

	DROP TABLE _ЗаписиВерсииРасписания;
END
$$;





SELECT (
	SELECT 1
	FROM sch.ЗаписиВерсииРасписанияСозадть(
		2, 
		Доктора.Код, 
		'01.06.2024'::date, 
		'15.06.2024'::date, 
		(random() * 3 + 1)::int, 
		(random() * 9 + 1)::int, 
		('[{"КодТипа": ' || ТипыИсследованийПодробно.Код::varchar || ', "Количество": ' || (random() * 100 + 1)::int::varchar || '}]')::json
	)
    LIMIT 1
)
FROM hr.Доктора
INNER JOIN hr.МодальностиДокторов ON МодальностиДокторов.КодДоктора = Доктора.Код AND МодальностиДокторов.Основная
INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.КодМодальности = МодальностиДокторов.КодМодальности
LIMIT 100




CREATE OR REPLACE VIEW sch.РасписаниеДокторовТаблицей
AS
SELECT
	СменыНаМесяц.КодВерсииПроектаРасписания,
	ВерсииПроектовРасписания.Утверждено,
	Диапазон::date,

	ДоктораПодробно.Код КодДоктора,
	ДоктораПодробно.ФИО,
	ДоктораПодробно.Ставка,
	ДоктораПодробно.ТабНомер,
	ДоктораПодробно.Модальности,

	СменыНаМесяц.ПоДням СменыНаМесяц, 
	СменыНаМесяц.Итог1,
	СменыНаМесяц.Итог2,

	СменыНаМесяц.Итог1 + СменыНаМесяц.Итог2 НормаЧасовПоГрафику,
	НормыДокторовПодробно.НормаЧасов НормаЧасовЗаПолныйМесяц

FROM generate_series(
	date_trunc('month', (SELECT MIN(ДатаНачала) FROM sch.ПроектыРасписания)), 
	date_trunc('month', (SELECT MAX(ДатаОкончания) FROM sch.ПроектыРасписания) + '1 month'::interval) - '1 day'::interval,
	'1 month'::interval
) Диапазон

INNER JOIN (
	SELECT
		date_trunc('month', Диапазон) ДатаНачалаМесяца,
		ВерсииПроектовРасписания.Код КодВерсииПроектаРасписания,
		Доктора.Код КодДоктора,

		json_agg(
			json_build_object(
				'Дата', Диапазон::date, 
				'Запись', row_to_json(ЗаписиВерсииРасписания), 
				'Смена', row_to_json(ТипыРабочихСмен),
				'Исследования', Исследования.Исследования
			) ORDER BY Диапазон
		) ПоДням,

		SUM(CASE WHEN EXTRACT (DAY FROM Диапазон) <= EXTRACT (DAY FROM ((date_trunc('month', Диапазон) + '1 month'::interval) - '1 day'::interval)) / 2 THEN ТипыРабочихСмен.Продолжительность END) Итог1,
		SUM(CASE WHEN EXTRACT (DAY FROM Диапазон) > EXTRACT (DAY FROM ((date_trunc('month', Диапазон) + '1 month'::interval) - '1 day'::interval)) / 2 THEN ТипыРабочихСмен.Продолжительность END) Итог2

	FROM hr.Доктора 

	CROSS JOIN sch.ВерсииПроектовРасписания
	INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания

	CROSS JOIN generate_series(
		date_trunc('month', ПроектыРасписания.ДатаНачала), 
		date_trunc('month', ПроектыРасписания.ДатаОкончания + '1 month'::interval) - '1 day'::interval,
		'1 day'::interval
	) Диапазон
	
	LEFT JOIN sch.ЗаписиВерсииРасписания ON ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = ВерсииПроектовРасписания.Код
	                                    AND ЗаписиВерсииРасписания.КодДоктора = Доктора.Код
	                                    AND ЗаписиВерсииРасписания.Дата = Диапазон
	LEFT JOIN hr.ТипыРабочихСмен ON ТипыРабочихСмен.Код = ЗаписиВерсииРасписания.КодТипаРабочейСмены

	LEFT JOIN (
		SELECT
			Исследования.КодЗаписи,
			json_agg(json_build_object('Тип', row_to_json(ТипыИсследованийПодробно), 'Количество', Исследования.Количество)) Исследования
		FROM sch.Исследования
		INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.Код = Исследования.КодТипаИсследования
		GROUP BY Исследования.КодЗаписи
	) Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код


	GROUP BY date_trunc('month', Диапазон), 
			 ВерсииПроектовРасписания.Код,
	         Доктора.Код
	
) СменыНаМесяц ON СменыНаМесяц.ДатаНачалаМесяца = Диапазон

INNER JOIN sch.ВерсииПроектовРасписания ON ВерсииПроектовРасписания.Код = СменыНаМесяц.КодВерсииПроектаРасписания
INNER JOIN hr.ДоктораПодробно ON ДоктораПодробно.Код = СменыНаМесяц.КодДоктора
INNER JOIN hr.НормыДокторовПодробно ON НормыДокторовПодробно.КодДоктора = СменыНаМесяц.КодДоктора

ORDER BY Диапазон;




CREATE OR REPLACE VIEW sch.НагрузкаДокторов1
AS
SELECT 
	Доктора.Код КодДоктора,
	ТипыИсследований.Код КодТипаИсследования,
	row_to_json(ТипыИсследований) ТипыИсследований,

	json_agg(json_build_object('Дата', КоличествоИсследований.Дата, 'Значение', COALESCE (КоличествоИсследований.Количество, 0)) ORDER BY КоличествоИсследований.Дата) Исследования,
	SUM(КоличествоИсследований.Количество) Количество

FROM hr.Доктора

INNER JOIN (
	SELECT
		ЗаписиВерсииРасписания.КодДоктора,
		ЗаписиВерсииРасписания.Дата,
		Исследования.КодТипаИсследования,
		SUM(Исследования.Количество) Количество
	FROM sch.ВерсииПроектовРасписания
	INNER JOIN sch.ЗаписиВерсииРасписания ON ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = ВерсииПроектовРасписания.Код
	INNER JOIN sch.Исследования ON Исследования.КодЗаписи = ЗаписиВерсииРасписания.Код
	WHERE ВерсииПроектовРасписания.Утверждено
	  AND ЗаписиВерсииРасписания.Дата BETWEEN (CURRENT_DATE + '-2 month'::interval) AND (CURRENT_DATE + '1 month'::interval)
	GROUP BY
		ЗаписиВерсииРасписания.КодДоктора,
		ЗаписиВерсииРасписания.Дата,
		Исследования.КодТипаИсследования
) КоличествоИсследований ON КоличествоИсследований.КодДоктора = Доктора.Код
INNER JOIN med.ТипыИсследований ON ТипыИсследований.Код = КоличествоИсследований.КодТипаИсследования

GROUP BY Доктора.Код, ТипыИсследований.Код
ORDER BY Доктора.Код, ТипыИсследований.Код;







CREATE OR REPLACE FUNCTION sch.ЗаписиВерсииРасписанияСохранить (
	_КодВерсииПроектаРасписания INT,

	_Данные JSON
)
RETURNS SETOF void
LANGUAGE plpgsql
AS $$
DECLARE _Код INT;
BEGIN


	INSERT INTO sch.ЗаписиВерсииРасписания (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены)
	SELECT DISTINCT _КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаРабочейСмены
	FROM json_array_elements(_Данные) q(c),
	     json_to_record(q.c) Исследование (Дата DATE, КодДоктора INT, КодТипаРабочейСмены INT, КодТипаИсследования INT, Количество INT);


	INSERT INTO sch.Исследования (КодЗаписи, КодТипаИсследования, Количество)
	SELECT ЗаписиВерсииРасписания.Код, КодТипаИсследования, Количество
	FROM json_array_elements(_Данные) q(c),
	     json_to_record(q.c) Исследование (Дата DATE, КодДоктора INT, КодТипаРабочейСмены INT, КодТипаИсследования INT, Количество INT)
	INNER JOIN sch.ЗаписиВерсииРасписания ON ЗаписиВерсииРасписания.КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
	                                     AND ЗаписиВерсииРасписания.КодДоктора = Исследование.КодДоктора
	                                     AND ЗаписиВерсииРасписания.Дата = Исследование.Дата;
END
$$;


CREATE OR REPLACE VIEW sch.СтатистикаДляПроекта
AS
SELECT
	КодПроекта,
	ROW_NUMBER() OVER (PARTITION BY КодПроекта ORDER BY ДатаНачалаНедели) НомерНеделиПроекта,
	ДатаНачалаНедели,
	Модальности
FROM (
	SELECT 
		ПроектыРасписания.Код КодПроекта,
		НеделяПроекта::date ДатаНачалаНедели,

		json_agg(json_build_object(
			'Модальность', row_to_json(Модальности),
			'КоличествоИсследованийПрогнозируемое', COALESCE(СтатистикаОбращенийМодальностей.Количество, 0),
			'КоличествоДокторвДляЗакрытия', (COALESCE(СтатистикаОбращенийМодальностей.Количество, 0) / ((МодальностиМинМакс.МаксКолИсследованийЗаСмену / 8) * (SELECT EXTRACT (EPOCH FROM Значение::varchar::interval) / 60 / 60 начение FROM stg.Параметры WHERE Ключ = 'ConditionallyMandatoryDistributionFor1RatePerWeek')))::int
		) ORDER BY Модальности.Код) Модальности

	FROM sch.ПроектыРасписания
	CROSS JOIN generate_series(
		date_trunc('week', ПроектыРасписания.ДатаНачала),
		date_trunc('week', ПроектыРасписания.ДатаОкончания) + '6 day'::interval,
		'1 week'::interval
	) НеделяПроекта
	CROSS JOIN med.Модальности
	LEFT JOIN (
		SELECT 
			СтатистикаОбращений.Дата,
			ТипыИсследований.КодМодальности,
			SUM(COALESCE(СтатистикаОбращений.Значение, 0)) Количество
		FROM nn.СтатистикаОбращений 
		INNER JOIN med.ТипыИсследований ON ТипыИсследований.Код = СтатистикаОбращений.КодТипаИсследования
		WHERE СтатистикаОбращений.КодТипа = 4
		GROUP BY СтатистикаОбращений.Дата, ТипыИсследований.КодМодальности
	) СтатистикаОбращенийМодальностей ON СтатистикаОбращенийМодальностей.Дата = НеделяПроекта
									 AND СтатистикаОбращенийМодальностей.КодМодальности = Модальности.Код

	LEFT JOIN (
		SELECT
			ТипыИсследований.КодМодальности,
			MIN (МинКолИсследованийЗаСмену) МинКолИсследованийЗаСмену,
			MAX (МаксКолИсследованийЗаСмену) МаксКолИсследованийЗаСмену
		FROM med.ТипыИсследований
		GROUP BY ТипыИсследований.КодМодальности
	) МодальностиМинМакс ON МодальностиМинМакс.КодМодальности = Модальности.Код

	GROUP BY ПроектыРасписания.Код, НеделяПроекта::date
) Запрос



