

CREATE TABLE sch.СтатусыПроектов (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	Название VARCHAR(300),
	МожноРедактировать BOOLEAN NOT NULL DEFAULT (false),
	МожноМенятьВерсию BOOLEAN NOT NULL DEFAULT (false),
	МожноВернутьНаФормирование BOOLEAN NOT NULL DEFAULT (false),
	МожноОтправитьНаСогласование BOOLEAN NOT NULL DEFAULT (false),
	МожноСоглосовать BOOLEAN NOT NULL DEFAULT (false),
	МожноОпубликовать BOOLEAN NOT NULL DEFAULT (false)
);

INSERT INTO sch.СтатусыПроектов (Название)
VALUES 
('Формируется'),
('На согласование'),
('Согласовано'),
('Опубликовано');



CREATE TABLE sch.ПроектыРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	ДатаНачала DATE,
	ДатаОкончания DATE,

	КодСтатуса INT NOT NULL REFERENCES sch.СтатусыПроектов (Код),

	CHECK (ДатаНачала <= ДатаОкончания),

	CONSTRAINT "Уже существует проект на указанный диапазон" EXCLUDE USING GIST (daterange(ДатаНачала, ДатаОкончания, '[]') with &&)
);

CREATE TABLE sch.ВерсииПроектовРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	ДатаСоздания TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP),
	КодПроектаРасписания INT NOT NULL REFERENCES sch.ПроектыРасписания (Код),
	Опубликовано BOOLEAN NOT NULL DEFAULT (false)
);


ALTER TABLE sch.ПроектыРасписания
ADD КодВерсииТекущей INT NULL REFERENCES sch.ВерсииПроектовРасписания (Код);



CREATE TABLE sch.СогласованиеВерсий (
	КодВерсииПроектаРасписания INT NOT NULL REFERENCES sch.ВерсииПроектовРасписания (Код),
	КодДоктора INT NOT NULL REFERENCES hr.Доктора (Код),
	Согласовано BOOLEAN NULL,

	PRIMARY KEY (КодВерсииПроектаРасписания, КодДоктора)
);


CREATE TABLE sch.Исследования (
	КодВерсииПроектаРасписания INT NOT NULL REFERENCES sch.ВерсииПроектовРасписания (Код),

	КодДоктора INT NOT NULL REFERENCES hr.Доктора (Код),
	КодТипаИсследования INT NOT NULL REFERENCES med.ТипыИсследований (Код),

	Дата DATE NOT NULL,
	ВремяНачала TIME NOT NULL,
	ВремяОкончания TIME NOT NULL GENERATED ALWAYS AS (ВремяНачала + ВремяРаботы::interval + Перерыв::interval) STORED,
    ВремяРаботы TIME NOT NULL,
    Перерыв TIME NOT NULL,


	PRIMARY KEY (КодВерсииПроектаРасписания, КодДоктора, Дата),

    CONSTRAINT "Время работы должно быть больше" CHECK ('00:00' < ВремяРаботы),
    CONSTRAINT "Перерыв превышает время работы" CHECK (Перерыв < ВремяРаботы)
);


CREATE TABLE sch.ТипыЗапросов (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	Название VARCHAR(300)
);

INSERT INTO sch.ТипыЗапросов (Название)
VALUES 
('Генерация с учетом графика сотрудника'),
('Генерация без учета графика сотрудника')



CREATE TABLE sch.ЗапросыНаГенерациюРасписания (
	Код INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

	КодПроектаРасписания INT NOT NULL REFERENCES sch.ПроектыРасписания (Код),

	КодВерсии INT NULL REFERENCES sch.ВерсииПроектовРасписания (Код),

	КодТипа INT NULL REFERENCES sch.ТипыЗапросов (Код),

	Выполнено boolean DEFAULT (false),

	Активно boolean DEFAULT (true),

	ДатаСоздания TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP)
);

CREATE OR REPLACE VIEW sch.НесоответствияВерсий
AS 
SELECT 
	Исследования.*,
	'Расписание не соответствует графику работы сотрудника' Описание
FROM sch.Исследования
LEFT JOIN hr.РабочееВремя ON РабочееВремя.КодДоктора = Исследования.КодДоктора
                         AND РабочееВремя.Дата = Исследования.Дата
WHERE РабочееВремя.КодДоктора IS NULL
   OR РабочееВремя.ВремяНачала <> Исследования.ВремяНачала
   OR РабочееВремя.ВремяОкончания <> Исследования.ВремяОкончания
   OR РабочееВремя.ВремяРаботы <> Исследования.ВремяРаботы
   OR РабочееВремя.Перерыв <> Исследования.Перерыв;
   



CREATE OR REPLACE VIEW sch.ИсследованияПодробно
AS
SELECT 
	Исследования.*,
	(EXTRACT(EPOCH FROM Исследования.ВремяРаботы) / EXTRACT(EPOCH FROM ТипыИсследованийПодробно.НормаВремени))::int ЧислоИсследований,
	row_to_json(ДоктораПодробно) Доктор, 
	row_to_json(ТипыИсследованийПодробно) ВидИсследования
FROM sch.Исследования
INNER JOIN hr.ДоктораПодробно ON ДоктораПодробно.Код = Исследования.КодДоктора
INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.Код = Исследования.КодТипаИсследования;




CREATE OR REPLACE VIEW sch.ПроектыПодробно
AS
SELECT 
	ПроектыРасписания.*,
	row_to_json(СтатусыПроектов) Статус,
	ЗапросыНаГенерациюРасписания.ЗапросыНаГенерациюРасписания,
	ВерсииПроектовРасписания.Версии
FROM sch.ПроектыРасписания
LEFT JOIN sch.СтатусыПроектов ON СтатусыПроектов.Код = ПроектыРасписания.КодСтатуса
LEFT JOIN (
    SELECT КодПроектаРасписания, json_agg(row_to_json(ЗапросыНаГенерациюРасписания)) ЗапросыНаГенерациюРасписания
    FROM sch.ЗапросыНаГенерациюРасписания
	WHERE CURRENT_DATE - INTERVAL'1 day' < ДатаСоздания
    GROUP BY КодПроектаРасписания
) ЗапросыНаГенерациюРасписания ON ЗапросыНаГенерациюРасписания.КодПроектаРасписания = ПроектыРасписания.Код
LEFT JOIN (
    SELECT КодПроектаРасписания, json_agg(row_to_json(ВерсииПроектовРасписания) ORDER BY ВерсииПроектовРасписания.ДатаСоздания) Версии
    FROM sch.ВерсииПроектовРасписания
    GROUP BY КодПроектаРасписания
) ВерсииПроектовРасписания ON ВерсииПроектовРасписания.КодПроектаРасписания = ПроектыРасписания.Код;






CREATE OR REPLACE FUNCTION sch.ПоследнийЗапросПроекта (_КодПроекта INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
RETURN QUERY
SELECT ЗапросыНаГенерациюРасписания.*
FROM sch.ЗапросыНаГенерациюРасписания
INNER JOIN (
	SELECT КодПроектаРасписания, MAX(ДатаСоздания) ДатаСоздания
	FROM sch.ЗапросыНаГенерациюРасписания
	GROUP BY КодПроектаРасписания
) МаксЗапросы ON МаксЗапросы.КодПроектаРасписания = ЗапросыНаГенерациюРасписания.КодПроектаРасписания
             AND МаксЗапросы.ДатаСоздания = ЗапросыНаГенерациюРасписания.ДатаСоздания
WHERE ЗапросыНаГенерациюРасписания.КодПроектаРасписания = _КодПроекта;
END
$$;


CREATE OR REPLACE FUNCTION sch.СоздатьЗапросНаГенерацию (_КодПроекта INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN

UPDATE sch.ЗапросыНаГенерациюРасписания 
SET Активно = false 
WHERE КодПроектаРасписания = _КодПроекта;

RETURN QUERY
INSERT INTO sch.ЗапросыНаГенерациюРасписания (КодПроектаРасписания)
VALUES (_КодПроекта)
RETURNING *;
END
$$;

CREATE OR REPLACE FUNCTION sch.ЗапросыНаГенерациюРасписанияPop ()
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
RETURN QUERY
SELECT *
FROM sch.ЗапросыНаГенерациюРасписания
WHERE Активно 
  AND NOT Выполнено
ORDER BY ДатаСоздания
LIMIT 1;
END
$$;

CREATE OR REPLACE FUNCTION sch.ЗапросыНаГенерациюРасписаниCommit (_Код INT)
RETURNS SETOF sch.ЗапросыНаГенерациюРасписания
LANGUAGE plpgsql
AS $$
BEGIN
RETURN QUERY
UPDATE sch.ЗапросыНаГенерациюРасписания 
SET Выполнено = true 
WHERE Код = _Код
RETURNING *;
END
$$;







CREATE OR REPLACE FUNCTION sch.ПроектыРасписанияSet (
    _Код INT,
	_ДатаНачала DATE,
	_ДатаОкончания DATE
)
RETURNS SETOF sch.ПроектыПодробно
LANGUAGE plpgsql
AS $$
BEGIN
    IF (_Код IS NULL) THEN
		INSERT INTO sch.ПроектыРасписания (ДатаНачала, ДатаОкончания, КодСтатуса)
        VALUES (_ДатаНачала, _ДатаОкончания, 1)
        RETURNING Код INTO _Код;

		PERFORM sch.ПроектыРасписанияСоздатьВерсию (_Код, NULL);
    ELSE
        UPDATE sch.ПроектыРасписания 
        SET ДатаНачала = COALESCE (_ДатаНачала, ДатаНачала),
            ДатаОкончания = COALESCE (_ДатаОкончания, ДатаОкончания)
        WHERE Код = _Код;
	END IF;

	RETURN QUERY
    SELECT *
    FROM sch.ПроектыПодробно
    WHERE Код = _Код;
END
$$;

CREATE OR REPLACE FUNCTION sch.НаФормирование (
	_КодПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE _КодВерсииТекущей INT;
BEGIN

	SELECT КодВерсииТекущей 
	INTO _КодВерсииТекущей
	FROM sch.ПроектыРасписания
	WHERE Код = _КодПроектаРасписания;

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 1, 
	    КодВерсииТекущей = NULL
	WHERE Код = _КодПроектаРасписания;

	IF _КодВерсииТекущей IS NOT NULL THEN
		PERFORM sch.ПроектыРасписанияСоздатьВерсию (_КодПроектаРасписания, _КодВерсииТекущей);
	END IF;

	UPDATE sch.ВерсииПроектовРасписания
	SET Опубликовано = false
	WHERE КодПроектаРасписания = _КодПроектаРасписания;

	DELETE
	FROM sch.СогласованиеВерсий
	WHERE EXISTS (
		SELECT *
		FROM sch.ВерсииПроектовРасписания
		WHERE ВерсииПроектовРасписания.Код = СогласованиеВерсий.КодВерсииПроектаРасписания
		  AND ВерсииПроектовРасписания.КодПроектаРасписания = _КодПроектаРасписания
	);
END
$$;


CREATE OR REPLACE FUNCTION sch.НаСогласование (
	_КодПроектаРасписания INT,
	_КодВерсииПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 2, КодВерсииТекущей = _КодВерсииПроектаРасписания
	WHERE ПроектыРасписания.Код = _КодПроектаРасписания;

	INSERT INTO sch.СогласованиеВерсий (КодВерсииПроектаРасписания, КодДоктора)
	SELECT DISTINCT _КодВерсииПроектаРасписания, КодДоктора
	FROM sch.Исследования
	WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания 
	ON CONFLICT (КодВерсииПроектаРасписания, КодДоктора) DO 
    UPDATE SET Согласовано = EXCLUDED.Согласовано;

	PERFORM event.СоздатьУведомление (
		'Есть проект расписания требующий вашего согласования.', 
		NULL, (SELECT array_agg(DISTINCT users.id) 
		FROM sch.Исследования 
		INNER JOIN public.users ON users.hr_id = Исследования.КодДоктора
		WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
	));
END
$$;



CREATE OR REPLACE FUNCTION sch.Согласовать (
	_КодПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 3
	WHERE Код = _КодПроектаРасписания;
END
$$;




CREATE OR REPLACE FUNCTION sch.Опубликовать (
	_КодПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE _КодВерсииПроектаРасписания INT;
BEGIN

	UPDATE sch.ПроектыРасписания
	SET КодСтатуса = 4
	WHERE Код = _КодПроектаРасписания
	RETURNING КодВерсииТекущей INTO _КодВерсииПроектаРасписания;

	UPDATE sch.ВерсииПроектовРасписания
	SET Опубликовано = true
	WHERE Код = _КодВерсииПроектаРасписания;
END
$$;






CREATE OR REPLACE FUNCTION sch.ПроектыРасписанияСоздатьВерсию (
	_КодПроектаРасписания INT,
	_КодВерсииПроектаРасписания INT
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE _КодВерсииНовой INT;
BEGIN
	INSERT INTO sch.ВерсииПроектовРасписания (КодПроектаРасписания)
	VALUES (_КодПроектаРасписания)
	RETURNING Код INTO _КодВерсииНовой;

	INSERT INTO sch.Исследования (КодВерсииПроектаРасписания, КодДоктора, КодТипаИсследования, Дата, ВремяНачала, ВремяРаботы, Перерыв)
	SELECT _КодВерсииНовой, КодДоктора, КодТипаИсследования, Дата, ВремяНачала, ВремяРаботы, Перерыв
	FROM sch.Исследования
	WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания;
END
$$;



CREATE OR REPLACE FUNCTION sch.ИсследованияSet (
	_КодВерсииПроектаРасписания INT,
	_КодДоктора INT,
	_Дата DATE,

	_КодТипаИсследования INT,
	_ВремяНачала TIME,
    _ВремяРаботы TIME,
    _Перерыв TIME
)
RETURNS SETOF sch.ИсследованияПодробно
LANGUAGE plpgsql
AS $$
BEGIN
	IF (
		NOT EXISTS (
			SELECT * 
			FROM sch.ВерсииПроектовРасписания
			INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания
			WHERE ВерсииПроектовРасписания.Код = _КодВерсииПроектаРасписания 
			  AND _Дата BETWEEN ПроектыРасписания.ДатаНачала AND ПроектыРасписания.ДатаОкончания
		)
	) THEN
		RAISE EXCEPTION 'Дата не входит в выбранный проект';
	END IF;


	INSERT INTO sch.Исследования (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаИсследования, ВремяНачала, ВремяРаботы, Перерыв)
    VALUES (_КодВерсииПроектаРасписания, _КодДоктора, _Дата, _КодТипаИсследования, _ВремяНачала, _ВремяРаботы, _Перерыв)
    ON CONFLICT (КодВерсииПроектаРасписания, КодДоктора, Дата) DO 
    UPDATE SET ВремяНачала = EXCLUDED.ВремяНачала,
               ВремяРаботы = EXCLUDED.ВремяРаботы,
               Перерыв = EXCLUDED.Перерыв;

	RETURN QUERY
    SELECT *
    FROM sch.ИсследованияПодробно
    WHERE КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
      AND КодДоктора = _КодДоктора
      AND Дата = _Дата;
END
$$;



CREATE OR REPLACE FUNCTION sch.ИсследованияНаПериодSet (

	_КодВерсииПроектаРасписания INT,
	_КодДоктора INT,

	_ДатаНачала DATE,
	_ДатаОкончания DATE,
	_КодГрафикаРаботы INT,

	_КодТипаИсследования INT,
	_ВремяНачала TIME,
    _ВремяРаботы TIME,
    _Перерыв TIME
)
RETURNS SETOF sch.ИсследованияПодробно
LANGUAGE plpgsql
AS $$
BEGIN

	IF (
		NOT EXISTS (
			SELECT * 
			FROM sch.ВерсииПроектовРасписания
			INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания
			WHERE ВерсииПроектовРасписания.Код = _КодВерсииПроектаРасписания 
			  AND _ДатаНачала <= _ДатаОкончания
			  AND ПроектыРасписания.ДатаНачала <= _ДатаНачала 
			  AND _ДатаОкончания <= ПроектыРасписания.ДатаОкончания
		)
	) THEN
		RAISE EXCEPTION 'Дата не входит в выбранный проект';
	END IF;


	CREATE TEMPORARY TABLE Даты (
	   Даты DATE PRIMARY KEY
	);


	INSERT INTO Даты (Дата)
	SELECT Дата
	FROM generate_series(_ДатаНачала, _ДатаОкончания, ((SELECT ГрафикиРаботы.ДнейЦикла FROM hr.ГрафикиРаботы WHERE ГрафикиРаботы.Код = _КодГрафикаРаботы)::varchar || ' day')::interval) Дата;

	INSERT INTO sch.Исследования (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаИсследования, ВремяНачала, ВремяРаботы, Перерыв)
    SELECT _КодВерсииПроектаРасписания, _КодДоктора, Даты.Дата, _КодТипаИсследования, _ВремяНачала, _ВремяРаботы, _Перерыв
	FROM Даты
    ON CONFLICT (КодВерсииПроектаРасписания, КодДоктора, Дата) DO 
    UPDATE SET ВремяНачала = EXCLUDED.ВремяНачала,
               ВремяРаботы = EXCLUDED.ВремяРаботы,
               Перерыв = EXCLUDED.Перерыв;

	RETURN QUERY
    SELECT ИсследованияПодробно.*
    FROM sch.ИсследованияПодробно
	INNER JOIN Даты ON ИсследованияПодробно.КодВерсииПроектаРасписания = _КодВерсииПроектаРасписания
				   AND ИсследованияПодробно.КодДоктора = _КодДоктора
				   AND ИсследованияПодробно.Дата = Даты.Дата;

	DROP TABLE Даты;
END
$$;


SELECT (
    SELECT 1
    FROM sch.ИсследованияПоГрафикуРаботыSet (
        5,
		Доктора.Код,
        '01.06.2024'::date, '30.06.2024'::date, 
        ТипыИсследованийПодробно.Код
    ) 
    LIMIT 1
)
FROM hr.Доктора
INNER JOIN hr.МодальностиДокторов ON МодальностиДокторов.КодДоктора = Доктора.Код AND МодальностиДокторов.Основная
INNER JOIN med.ТипыИсследованийПодробно ON ТипыИсследованийПодробно.КодМодальности = МодальностиДокторов.КодМодальности
LIMIT 100





CREATE OR REPLACE FUNCTION sch.ИсследованияПоГрафикуРаботыSet (
	_КодВерсииПроектаРасписания INT,
	_КодДоктора INT,
	_ДатаНачала DATE,
	_ДатаОкончания DATE,
	_КодТипаИсследования INT
)
RETURNS SETOF sch.ИсследованияПодробно
LANGUAGE plpgsql
AS $$
BEGIN

	IF (
		NOT EXISTS (
			SELECT * 
			FROM sch.ВерсииПроектовРасписания
			INNER JOIN sch.ПроектыРасписания ON ПроектыРасписания.Код = ВерсииПроектовРасписания.КодПроектаРасписания
			WHERE ВерсииПроектовРасписания.Код = _КодВерсииПроектаРасписания 
			  AND _ДатаНачала <= _ДатаОкончания
			  AND ПроектыРасписания.ДатаНачала <= _ДатаНачала 
			  AND _ДатаОкончания <= ПроектыРасписания.ДатаОкончания
		)
	) THEN
		RAISE EXCEPTION 'Дата не входит в выбранный проект';
	END IF;

	INSERT INTO sch.Исследования (КодВерсииПроектаРасписания, КодДоктора, Дата, КодТипаИсследования, ВремяНачала, ВремяРаботы, Перерыв)
    SELECT _КодВерсииПроектаРасписания, _КодДоктора, РабочееВремя.Дата, _КодТипаИсследования, РабочееВремя.ВремяНачала, РабочееВремя.ВремяРаботы, РабочееВремя.Перерыв
	FROM hr.РабочееВремя
	WHERE КодДоктора = _КодДоктора
	  AND Дата BETWEEN _ДатаНачала AND _ДатаОкончания
    ON CONFLICT (КодВерсииПроектаРасписания, КодДоктора, Дата) DO 
    UPDATE SET ВремяНачала = EXCLUDED.ВремяНачала,
               ВремяРаботы = EXCLUDED.ВремяРаботы,
               Перерыв = EXCLUDED.Перерыв;

	RETURN QUERY
    SELECT ИсследованияПодробно.*
    FROM sch.ИсследованияПодробно
	INNER JOIN hr.РабочееВремя ON РабочееВремя.КодДоктора = ИсследованияПодробно.КодДоктора
	                          AND РабочееВремя.Дата = ИсследованияПодробно.Дата
	WHERE ИсследованияПодробно.КодДоктора = _КодДоктора
	  AND ИсследованияПодробно.Дата BETWEEN _ДатаНачала AND _ДатаОкончания;
END
$$;



